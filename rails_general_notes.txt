Rails Notes (rails command and rake)
===============================================================================

- https://github.com/rohandaxini/rails-concepts-topics


1. What are all naming conventions I need to be aware of?

	db table is plural, 
	model is singular, 
	controller is plural. 
	so you have the User model that is backed by the users table, and visible through the UsersController.


	files should be named as the wide_cased version of the class name. 
	so the FooBar class needs to be in a file called foo_bar.rb. 
	
	If you are namespacing with modules, the namespaces need to be represented by folders. 
	so if we are talking about Foo::Bar class, it should be in foo/bar.rb.

2. How should controller actions be structured and named?

	Controller actions should be RESTful. 
	That means that you should think of your controllers as exposing a resource, not as just enabling RPCs. 
	
	Rails has a concept of member actions vs collection actions for resources. 
	
		- A member action is something that operates on a specific instance, for example /users/1/edit would be an edit member action for users. 
		- A collection action is something that operates on all the resources. So /users/search?name=foo would be a collection action.

	The tutorials above describe how to actually implement these ideas in your routes file.

3. What are the best ways to render information in a view (via :content_for or render a partial) and what are ways I shouldn't use?

	content_for should be used when you want to be able to append html from an inner template to an outer template 
	-- for example, being able to append something from your view template into your layout template. 
	
	A good example would be to add a page specific javascript.

		# app/views/layout/application.rb
		<html>
		  <head>
			<%= yield :head %>
		...

		# app/views/foobars/index.html.erb

		<% content_for :head do %>
		  <script type='text/javascript'>
			alert('zomg content_for!');
		  </script>
		<% end %>

	partials are either for breaking up large files, or for rendering the same bit of information multiple times. For example

		<table>
		  <%= render :partial => 'foo_row', :collection => @foobars %>
		</table>

	# _foo_row.html.erb

		<tr>
		 <td>
		  <%= foobar.name %>
		 </td>
		</tr>


4.What should go into a helper and what shouldn't?

	your templates should only have basic branching logic in them. 
	If you need to do anything more intense, it should be in a helper. 
	local variables in views are an abomination against all that is good and right in the world, so that is a great sign that you should make a helper.

	Another reason is just pure code reuse. 
	If you are doing the same thing with only slight variation over and over again, pull it into a helper (if it is the exact same thing, it should be in a partial).

5. What are common pitfalls or something I need to do correctly from the very beginning?

	partials should never refer directly to instance (@) variables, since it will prevent re-use down the line. 
	Always pass data in via the :locals => { :var_name => value } param to the render function.

	Keep logic out of your views that is not directly related to rendering your views. 
	If you have the option to do something in the view, and do it somewhere else, 9 times out of 10 doing it somewhere else is the better option.

	We have a mantra in rails that is "fat models, skinny controllers". 
	
	- One reason is that models are object oriented, controllers are inherantly procedural. 
	- Another is that models can cross controllers, but controllers cant cross models. 
	- A third is that models are more testable. Its just a good idea.

6. How can you modularize code? Is that what the lib folder is for?

	the lib folder is for code that crosses the concerns of models (i.e. something that isn't a model, but will be used by multiple models). 
	When you need to put something in there, you will know, because you wont be able to figure out what model to put it in. Until that happens, you can just ignore lib.

	Something to keep in mind is that as of rails 3, 
	lib is not on the autoload path, meaning that you need to require anything you put in there (or add it back in)

	A way to automatically require all modules in the lib directory:

	#config/initializers/requires.rb
	Dir[File.join(Rails.root, 'lib', '*.rb')].each do |f|
	  require f
	end


Rails Components
========================================================================

Action Pack
------------
# https://guides.rubyonrails.org/action_controller_overview.html

- Action Pack is a framework for handling and responding to web requests. 
- It provides mechanisms for routing (mapping request URLs to actions), defining controllers that implement actions, and generating responses. 
- In short, Action Pack provides the controller layer in the MVC paradigm.

- It consists of several modules:

	- Action Dispatch, which parses information about the web request, handles routing as defined by the user, and does advanced processing related to HTTP such as MIME-type negotiation, decoding parameters in POST, PATCH, or PUT bodies, handling HTTP caching logic, cookies and sessions.

	- Action Controller, which provides a base controller class that can be subclassed to implement filters and actions to handle requests. The result of an action is typically content generated from views.



ActionCable
------------

# Check https://docs.anycable.io for production performance engine

- Action Cable seamlessly integrates WebSockets with the rest of your Rails application. 
- It allows for real-time features to be written in Ruby in the same style and form as the rest of your Rails application, while still being performant and scalable. 
- It's a full-stack offering that provides both a client-side JavaScript framework and a server-side Ruby framework. 
- You have access to your entire domain model written with Active Record or your ORM of choice.



ActiveSupport
-------------
- Active Support is the Ruby on Rails component responsible for providing Ruby language extensions, utilities, and other transversal stuff.
# https://guides.rubyonrails.org/v3.2/active_support_core_extensions.html

	require 'active_support'
	
	blank? and present?
	try
	duplicable?
	singleton_class
	class_eval(*args, &block)
	acts_like?(duck)
	
	[0, true, String].to_param # => "0/true/String"
	
	account.to_query('company[name]')
	# => "company%5Bname%5D=Johnson+%26+Johnson"








actionmailbox (7.0.1)
actionmailer (7.0.1)
actiontext (7.0.1)

actionview (7.0.1)
activejob (7.0.1)

activemodel (7.0.1)
activerecord (7.0.1)

activestorage (7.0.1)
rails (7.0.1)
railties (7.0.1)



















Service Objects
------------------------------------------------------------------------

	# app/services/twitter_service.rb
	module TwitterService
	  def self.send_welcome_message(twitter_handle)
		client.update("@#{twitter_handle} welcome to 'Oranges & Apples', we hope you enjoy our juicy fruit!")
	  end
	  def self.client
		@client ||= Twitter::REST::Client.new do |config|
		  config.consumer_key        = "..."
		  config.consumer_secret     = "..."
		  config.access_token        = "..."
		  config.access_token_secret = "..."
		end
	  end
	end

	- your controller
	
	class UsersController
	  def create
		# ...
		TwitterService.send_welcome_message(user.twitter_handle)
	  end
	end
	
------

app/services/tweet_creator.rb

	# app/services/tweet_creator.rb
	class TweetCreator
	  def initialize(message)
		@message = message
	  end

	  def send_tweet
		client = Twitter::REST::Client.new do |config|
		  config.consumer_key        = ENV['TWITTER_CONSUMER_KEY']
		  config.consumer_secret     = ENV['TWITTER_CONSUMER_SECRET']
		  config.access_token        = ENV['TWITTER_ACCESS_TOKEN']
		  config.access_token_secret = ENV['TWITTER_ACCESS_SECRET']
		end
		client.update(@message)
	  end
	end


TweetCreator.new(params[:message]).send_tweet

Proccall invokes the block, setting the block’s parameters to the values in params using something close to method calling semantics. It returns the value of the last expression evaluated in the block.

	aproc = Proc.new {|scalar, values| values.map {|value| valuescalar } }
	aproc.call(9, 1, 2, 3)    #=> [9, 18, 27]
	aproc[9, 1, 2, 3]         #=> [9, 18, 27]
	aproc.(9, 1, 2, 3)        #=> [9, 18, 27]
	aproc.yield(9, 1, 2, 3)   #=> [9, 18, 27]

So let’s make our service object behave more like a proc!

	# app/services/application_service.rb
	class ApplicationService
	  def self.call(*args, &block)
		new(*args, &block).call
	  end
	end

.. then

	# app/services/tweet_creator.rb
	class TweetCreator < ApplicationService
	  attr_reader :message
	  
	  def initialize(message)
		@message = message
	  end

	  def call
		client = Twitter::REST::Client.new do |config|
		  config.consumer_key        = ENV['TWITTER_CONSUMER_KEY']
		  config.consumer_secret     = ENV['TWITTER_CONSUMER_SECRET']
		  config.access_token        = ENV['TWITTER_ACCESS_TOKEN']
		  config.access_token_secret = ENV['TWITTER_ACCESS_SECRET']
		end
		client.update(@message)
	  end
	end

	class TweetController < ApplicationController
	  def create
		TweetCreator.call(params[:message])
	  end
	end


Make lib autploaded
------------------------------------------------------------------------

application.rb

    config.autoload_paths << "#{Rails.root}/lib"












# https://codeburst.io/ruby-on-rails-concepts-explained-with-real-world-use-cases-588dc85d8e96

trailblazer
====================================================================================
The Advanced Business Logic Framework

https://trailblazer.to/2.0/index.html









Notes:
================

Maybe it will help to enable SQL logging and see if the correct data is sent to the database? 
ActiveRecord::Base.logger = Logger.new(STDOUT). – shock_one Feb 10 '15 at 21:04



References
==========
- https://github.com/markets/awesome-ruby










Translations
========================================================================
https://github.com/glebm/i18n-tasks
https://github.com/Sage/i18n_yaml_editor

> gem install i18n_yaml_editor
> i18n_yaml_editor path/to/i18n/locales [port]


-----------------------------------------------------------------------------------------------------------------------------------------------------------
Notes:
================

Maybe it will help to enable SQL logging and see if the correct data is sent to the database? 
ActiveRecord::Base.logger = Logger.new(STDOUT). – shock_one Feb 10 '15 at 21:04



References
==========
- https://github.com/markets/awesome-ruby



Design Patterns
=====================================================================================

- Factory
Class that has one creation method with a large conditional.

- Form object
Move form-specific logic away from your ActiveRecord models into a separate class.

	Submitting form data is a common feature of web applications – allowing users to submit their information and giving them feedback whether the information is valid or not.
	ActiveRecord comes with a powerful set of validators for attributes on a persisted data model. When data is not persisted, or used for other non-active record purposes, Active Model Helper Modules reduce the complexity of validations on your plain old Ruby objects.

	- Routing
	---------
	Create the routes needed for displaying the form object and posting the data
	Restrict resources to the routes you need using only:
	
		# config/routes.rb
		resources :registration, only: [:new, :create]

	- Controller and Actions
	------------------------
	Create a controller with new and create actions.

	respond_with will re-render the new action if there are any validation errors on the model
	If there are no errors on the model the visitor will be redirected to show the current resource. In this case the user will be redirected to some_other_success_path

		# app/controllers/registration_controller.rb
		class RegistrationsController < ApplicationController
		  respond_to :html

		  def new
			@registration = Registration.new
		  end

		  def create
			@registration = Registration.new(registration_params)
			@registration.register

			respond_with @registration, location: some_success_path
		  end

		  private

		  def registration_params
			# ...
		  end
		end

	- View with Registration Form
	------------------------------
	The view renders a web form with fields to submit.

	Use the ActiveModel object @registration in the form
	Form generates the endpoint registration_path and method of delivery post
	Validation errors will display inline within the form just like ActiveRecord

		# app/views/registration/new.html.erb
		<%= form_for @registration do |f| %>
		  <%= f.label :first_name, 'First Name' %>:
		  <%= f.text_field :first_name %>
		  ...
		  <%= f.submit %>
		<% end %>

	- Object with ActiveModel Conversion, Naming, and Validations
	-------------------------------------------------------------
	Use any of the ActiveRecord Validations in the model.

	Command pattern used when calling register method.
	ActiveRecord validation syntax on attributes.
	ActiveModel::Model mixin includes modules, and includes an initialization method.

		# app/models/registration.rb
		class Registration
		  include ActiveModel::Model

		  attr_accessor(
			:company_name,
			:email,
			:first_name,
			:last_name,
			:terms_of_service
		  )

		  validates :company_name, presence: true
		  validates :email, presence: true, email: true
		  validates :first_name, presence: true
		  validates :last_name, presence: true
		  validates :terms_of_service, acceptance: true

		  def register
			if valid?
			  # Do something interesting here
			  # - create user
			  # - send notifications
			  # - log events, etc.
			end
		  end

		  private

		  def create_user
			# ...
		  end
		end


- Value object
A small simple object, like a date range or location, whose equality isn’t based on identity.
<=>, hash, and eql? which allow us to make use of operations like sort and uniq. We get the following usage:

- Null object
Instead of returning null, or some odd value, return a Special Case that has the same interface as what the caller expects.

- Query object
Represent a database query or a set of database queries related to the same table.
# https://medium.flatstack.com/query-object-in-ruby-on-rails-56ea434365f0

- Service object
Concentrate the core logic of a request operation into a separate object.
# http://brewhouse.io/blog/2014/04/30/gourmet-service-objects.html

	A service object does one thing
	A service object (aka method object) performs one action. It holds the business logic to perform that action. Here is an example:

	class Invite < ActiveRecord::Base
	  def accept!(user, time=Time.now)
		update_attributes!(
		  accepted_by_user_id: user.id,
		  accepted_at: time
		)
	  end
	end

	# app/services/accept_invite.rb
	class AcceptInvite

	  def self.call(invite, user)
		invite.accept!(user)
		UserMailer.invite_accepted(invite).deliver
	  end

	end

	.. then
	
	class InviteController < ApplicationController
	  def accept
		invite = Invite.find_by_token!(params[:token])

		if AcceptInvite.call(invite, current_user)
		  redirect_to invite.item, notice: "Welcome!"
		else
		  redirect_to '/', alert: "Oopsy!"
		end
	  end
	end


- Decorators used in rails ... 

	


Background Jobs
========================================================================

- delayed_job
- Sidekiq : https://github.com/mperham/sidekiq





Some Handy Gems
========================================================================





Process management / puma / passenger / and cloud stuff ..... with nginx
========================================================================



nginx
======

> rails s =p 3005


nginx:


server {

        listen 443;

        ssl on;
        ssl_certificate /data/opt/nginx/conf/ssl/bundle.crt;
        ssl_certificate_key /data/opt/nginx/conf/ssl/d1g_com.key;
        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers         HIGH:!aNULL:!MD5;


        server_name www.d1g.com yasater.d1g.com hasnaa.d1g.com .d1g.com *.d1g.com d1g.com;
        rewrite ^/photos(.*)$ https://www.yasater.com/photos$1 last;

        rewrite ^/(.*)$ https://www.yasater.com/$1 redirect;

        location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_redirect off;
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                # try_files $uri $uri/ =404;
                proxy_pass http://127.0.0.1:3005;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules
        }
}





Missing `secret_key_base` for 'production' environment

RAILS_ENV=production rake secret -->

prodcuction.rb

config.secret_key_base = "1104db7a0342fc8b1f65c683681270b15f115bdf1477823ebe92b9ea10bcd0827b15e23db168c41ddcbd463986d0e8d72f8c5d0e0aac16827e8df093e15873a3"










Caching:
========
- https://guides.rubyonrails.org/caching_with_rails.html



















Templates
========================================================================

- https://guides.rubyonrails.org/rails_application_templates.html


Rails Temapltes (Bootstrapers)
------------------------------------------------------------------------
# https://guides.rubyonrails.org/rails_application_templates.html
















