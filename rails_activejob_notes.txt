Concepts
===========================================================================================
- create a job

	bin/rails generate job guests_cleanup	--> app/jobs/guests_cleanup_job.rb
	bin/rails generate job guests_cleanup --queue urgent
	
	Or create your own inside app/jobs
	
	class GuestsCleanupJob < ApplicationJob
	  queue_as :default

	  def perform(*guests)
		# Do something later
	  end
	end

- Enqueue

	GuestsCleanupJob.perform_later guest
	GuestsCleanupJob.set(wait_until: Date.tomorrow.noon).perform_later(guest)
	GuestsCleanupJob.set(wait: 1.week).perform_later(guest)
	GuestsCleanupJob.perform_later(guest1, guest2, filter: 'some_filter')

# Active Job has built-in adapters for multiple queuing backends:
	- Sidekiq	# https://github.com/mperham/sidekiq/wiki/Active-Job
	- Resque	# https://github.com/resque/resque/wiki/ActiveJob
	- Sneakers	# https://github.com/jondot/sneakers/wiki/How-To:-Rails-Background-Jobs-with-ActiveJob
	- Sucker Punch	# https://github.com/brandonhilkert/sucker_punch#active-job
	- Queue Classic # https://github.com/QueueClassic/queue_classic#active-job
	- Que 			# https://github.com/que-rb/que#additional-rails-specific-setup
	- Delayed Job, and others). # https://github.com/collectiveidea/delayed_job#active-job
	- Good Job # https://github.com/bensheldon/good_job#readme
	
	To get an up-to-date list of the adapters see the API Documentation for ActiveJob::QueueAdapters.

- Backend

	application.rb:
	
		config.active_job.queue_adapter = :sidekiq

	Or per Job
	
		class GuestsCleanupJob < ApplicationJob
			self.queue_adapter = :resque
			...
	
	- starting the backend depends on which backend you are using


- Queues

	# Default Rails queue is in-process thread pool (memory)
	
	- Most of the adapters support multiple queues.
	
		queue_as :low_priority
	
	- You can prefix the queue name for all your jobs using config.active_job.queue_name_prefix in application.rb:

		config.active_job.queue_name_prefix = Rails.env		--> queue_as :low_priority will be queued production_low_priority or staging_low_priority
		self.queue_name_prefix = nil	# per job
		
	- delimiter 
	
		config.active_job.queue_name_prefix = Rails.env
		config.active_job.queue_name_delimiter = '.'		--> production.low_priority
		
		
	- Queue at execution time
	
		MyJob.set(queue: :another_queue).perform_later(record)
		
	- as block
	
		class ProcessVideoJob < ApplicationJob
		  queue_as do
			video = self.arguments.first
			if video.owner.premium?
			  :premium_videojobs
			else
			  :videojobs
			end
		  end

		  def perform(video)
			# Do process video
		  end
		end
		
		ProcessVideoJob.perform_later(Video.last)
	
- Callbacks

	class GuestsCleanupJob < ApplicationJob
	  queue_as :default
	  around_perform :around_cleanup	<--

	  def perform
		# Do something later
	  end

	  private
		def around_cleanup
		  # Do something before perform
		  yield
		  # Do something after perform
		end
	end
	
	- For example, you could send metrics for every job enqueued:
	
	class ApplicationJob < ActiveJob::Base
	  before_enqueue { |job| $statsd.increment "#{job.class.name.underscore}.enqueue" }
	end

	- Callbacks
	
		before_enqueue
		around_enqueue
		after_enqueue
		before_perform
		around_perform
		after_perform
	
	
- Action Mailer

	UserMailer.welcome(@user).deliver_now
	UserMailer.welcome(@user).deliver_later		--> through Active Jobs
	
* Using the asynchronous queue from a Rake task (for example, to send an email using .deliver_later) will generally not work because Rake will likely end, causing the in-process thread pool to be deleted, before any/all of the .deliver_later emails are processed. To avoid this problem, use .deliver_now or run a persistent queue in development.


- Internationalization

	I18n.locale = :eo
	UserMailer.welcome(@user).deliver_later
	
- Supported Arguments

    Basic types (NilClass, String, Integer, Float, BigDecimal, TrueClass, FalseClass)
    Symbol
    Date
    Time
    DateTime
    ActiveSupport::TimeWithZone
    ActiveSupport::Duration
    Hash (Keys should be of String or Symbol type)
    ActiveSupport::HashWithIndifferentAccess
    Array
    Range
    Module
    Class

- GlobalID

	# This makes it possible to pass live Active Record objects to your job instead of class/id pairs
																	--> Simply
	class TrashableCleanupJob < ApplicationJob							
	  def perform(trashable_class, trashable_id, depth)					def perform(trashable, depth)
		trashable = trashable_class.constantize.find(trashable_id)			trashable.cleanup(depth)
		trashable.cleanup(depth)										end
	  end
	end

- Serializers	# https://guides.rubyonrails.org/active_job_basics.html#serializers

- Exceptions

	  rescue_from(ActiveRecord::RecordNotFound) do |exception|
		# Do something with the exception
	  end
		
* A failed job will not be retried, unless configured otherwise.
* It's possible to retry or discard a failed job by using retry_on or discard_on, respectively. For example:

	class RemoteServiceJob < ApplicationJob
	  retry_on CustomAppException # defaults to 3s wait, 5 attempts

	  discard_on ActiveJob::DeserializationError	<----

	  def perform(*args)
		# Might raise CustomAppException or ActiveJob::DeserializationError
	  end
	end














Delayed Job
===========================================================================================

# https://github.com/collectiveidea/delayed_job#installation

	gem 'delayed_job_active_record'
	gem "daemons"

	rails generate delayed_job:active_record
	rails db:migrate

# config/application.rb

	config.active_job.queue_adapter = :delayed_job

# config/initializers/delayed_job_config.rb
 
	Delayed::Worker.destroy_failed_jobs = false
	Delayed::Worker.sleep_delay = 60
	Delayed::Worker.max_attempts = 3
	Delayed::Worker.max_run_time = 5.minutes
	Delayed::Worker.read_ahead = 10
	Delayed::Worker.default_queue_name = 'default'
	Delayed::Worker.delay_jobs = !Rails.env.test?
	Delayed::Worker.raise_signal_exceptions = :term
	Delayed::Worker.logger = Logger.new(File.join(Rails.root, 'log', 'delayed_job.log'))
 

# This will create guests_cleanup_job.rb in jobs folder

	rails generate job guests_cleanup

# guests_cleanup_job.rb

	class GuestsCleanupJob < ActiveJob::Base
	  queue_as :default

	  def perform(*args)
		# Do something later
		# here you can call instant methods of passed objects (models) that performs long processing
		# args will include whatever object you pass for processing
		
		args.each do |arg|
			puts arg.class	# in the next example, it will print: Team, String
		end
		
	  end
	end
	
# For example

	model = Team.find_by_name("Red Star")
	GuestsCleanupJob.perform_later(model, "hello")

# Adding a Task to the Queue can be performed in many way .. .

	- GuestsCleanupJob.perform_later(model, "hello")	
	- GuestsCleanupJob.set(wait: 10.seconds).perform_later(model)
	- GuestsCleanupJob.delay(run_at: 5.seconds.from_now).perform_later("something")
	- GuestsCleanupJob.delay(run_at: 5.seconds.from_now).perform_now("something")

# So Jobs can be A job class, or a function in any model

	# without delayed_job
	@user.activate!(@device)

	# with delayed_job
	@user.delay.activate!(@device)

	# without delayed_job
	Notifier.signup(@user).deliver

	# with delayed_job
	Notifier.delay.signup(@user)

	# delayed_job running at a specific time
	Notifier.delay(run_at: 5.minutes.from_now).signup(@user)

	# when using parameters, the .with method must be called before the .delay method
	Notifier.with(foo: 1, bar: 2).delay.signup(@user)

# Or from any class (service maybe)

	class LongTasks
		def send_mailer
			# Some other code
		end
		...
		
		handle_asynchronously :send_mailer, :priority => 20
		handle_asynchronously :in_the_future, :run_at => Proc.new { 5.minutes.from_now }
		.....		
	end


# You can create custom jobs as following

	NewsletterJob = Struct.new(:text, :emails) do
		def perform
			emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
		end
	  
	  	# Override	  
		def max_attempts
			3
		end

		def max_run_time
			120 # seconds
		end

		def destroy_failed_jobs?
			false
		end

		def queue_name
		'newsletter_queue'
		end

		def reschedule_at(current_time, attempts)
			current_time + 5.seconds
		end	  
	end

	Delayed::Job.enqueue NewsletterJob.new('lorem ipsum...', Customers.pluck(:email))
	
# Hooks

	class ParanoidNewsletterJob < NewsletterJob
	  def enqueue(job)
		record_stat 'newsletter_job/enqueue'
	  end

	  def perform
		emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
	  end

	  def before(job)
		record_stat 'newsletter_job/start'
	  end

	  def after(job)
		record_stat 'newsletter_job/after'
	  end

	  def success(job)
		record_stat 'newsletter_job/success'
	  end

	  def error(job, exception)
		Airbrake.notify(exception)
	  end

	  def failure(job)
		page_sysadmin_in_the_middle_of_the_night
	  end
	end		
	
# Notice

On error, the job is scheduled again in 5 seconds + N ** 4, where N is the number of attempts or using the job's defined reschedule_at method.
The default Worker.max_attempts is 25. After this, the job is either deleted (default), or left in the database with "failed_at" set. With the default of 25 attempts, the last retry will be 20 days later, with the last interval being almost 100 hours.
The default Worker.max_run_time is 4.hours. If your job takes longer than that, another computer could pick it up. It's up to you to make sure your job doesn't exceed this time. You should set this to the longest time you think the job could take.


# To run the workers

	rake jobs:work		# self running, Ctl^C to exit
	rake jobs:workoff 	# run all jobs and exit
	rake jobs:clear 	# clean all jobs

	# run as  daemon
		
	RAILS_ENV=production bin/delayed_job start
	RAILS_ENV=production bin/delayed_job stop

	# Runs two workers in separate processes.
	RAILS_ENV=production bin/delayed_job -n 2 start
	RAILS_ENV=production bin/delayed_job stop

	# Set the --queue or --queues option to work from a particular queue.
	RAILS_ENV=production bin/delayed_job --queue=tracking start
	RAILS_ENV=production bin/delayed_job --queues=mailers,tasks start

	# Use the --pool option to specify a worker pool. You can use this option multiple times to start different numbers of workers for different queues.
	# The following command will start 1 worker for the tracking queue,
	# 2 workers for the mailers and tasks queues, and 2 workers for any jobs:
	RAILS_ENV=production bin/delayed_job --pool=tracking --pool=mailers,tasks:2 --pool=*:2 start

	# Runs all available jobs and then exits
	RAILS_ENV=production bin/delayed_job start --exit-on-complete
	# or to run in the foreground
	RAILS_ENV=production bin/delayed_job run --exit-on-complete

	# Restart
	RAILS_ENV=production bin/delayed_job restart
	RAILS_ENV=production bin/delayed_job -n2 restart

# Remember, to install daemons in order to use bin/delayed_job as a daemon.

	gem "daemons"
	

# table delayed_jobs in details

	create_table :delayed_jobs, :force => true do |table|
	  table.integer  :priority, :default => 0      # Allows some jobs to jump to the front of the queue
	  table.integer  :attempts, :default => 0      # Provides for retries, but still fail eventually.
	  table.text     :handler                      # YAML-encoded string of the object that will do work
	  table.text     :last_error                   # reason for last failure (See Note below)
	  table.datetime :run_at                       # When to run. Could be Time.zone.now for immediately, or sometime in the future.
	  table.datetime :locked_at                    # Set when a client is working on this object
	  table.datetime :failed_at                    # Set when all retries have failed (actually, by default, the record is deleted instead)
	  table.string   :locked_by                    # Who is working on this object (if locked)
	  table.string   :queue                        # The name of the queue this job is in
	  table.timestamps

	  table.cron	# added & used by cron job	
	end

# Cron jobs
-------------------
# You need to install 

	gem 'delayed_cron_job', '0.7.2'
	
	# create migration since we are using active record
	rails generate delayed_job:cron	
	rake db:migrate
	
# How to use

	Delayed::Job.enqueue(GuestsCleanupJob.new, cron: '* * * * *')	# every minute

# You may use the id of the Delayed::Job as returned by the #enqueue method to reference and/or remove the scheduled job in the future.
# Job must be PORO in case of croned jobs, no need to extend ActiveJob::Base

	class GuestsCleanupJob #< ActiveJob::Base
	  # queue_as :default
	  def perform(*args)
		# Do something later
		# logger.info "================================================="
		item = Item.first
		args.each do |p|
		  # logger.info p.class
		end
	  end
	end

# when create (enqueue) a job, try to get it's object 

	job = Delayed::Job.enqueue(GuestsCleanupJob.new, cron: '* * * * *')

	# you can get it's id, name .. etc
	job.id
	
	# you can 
	Delayed::Job.all
	obj = 	Delayed::Job.find(id)
	obj.destroy


# references
- https://github.com/ejschmitt/delayed_job_web
- https://github.com/javan/whenever
- https://crontab.guru/every-1-minute
- https://github.com/codez/delayed_cron_job/tree/v0.6.0
- https://davidmles.medium.com/a-quick-look-at-background-jobs-in-ruby-43e6176aeee5
- https://github.com/collectiveidea/delayed_job#installation


- text tables
	https://github.com/matt-harvey/tabulo
	
- machine learning 
	https://medium.com/devtechtoday/ruby-on-rails-in-machine-learning-artificial-intelligence-yay-or-nay-eb63db832f2a
	
- ransack 
	https://github.com/activerecord-hackery/ransack
	
- https://firrae.medium.com/wsl2-ruby-on-rails-and-development-performance-6a36e40bd38b
- https://www.hackerrank.com/challenges/ruby-methods-introduction/problem?utm_campaign=challenge-recommendation&utm_medium=email&utm_source=24-hour-campaign&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen
- hot wire
	https://gorails.com/episodes/hotwire-rails
	

# create another table to manage jobs (CRUD) jobs

	id
	name	# entered by user
	job_id	# job id	--> delayed_job_id --|
	description
	status
	created_at
	updated_at
	alert_id		<----		added
	every
	action
	template_id					--> templates: name, template
	group_by	'supplier_order_id'
	
	
  E_E =     {
    "Every 1 hour" => "0 * * * *",
    "Every 1 day" => "0 1 * * *",
    "Every 1 month" => "0 0 * * *",
    "Every 1 week" => "0 0 * * 0"
  }

actions:

  ACTIONS =     {
    "Send Customer E-mail" => "send_customer_email",
    "Send Ticket" => "send_ticket",
    "Notify Admin" => "notify_admin",
  }

  enum status: [:active, :paused]


# alerts

	id
	name
	query
	model
	
	
# alert_notifications

	alert_id
	model_type	(Order, Item, Supplier, User, Invoice, Payment)
	model_id
	
	action	# taken from trigger job 	
	status	[:ready, :done, :failed]
	

# templates

	name		string	<----- 
	template	text	(erb)
		
# tickets ..... 

	id
	ticket_type_id	--> ticket_types

#	model_type	(Order, Item, Supplier, User, Invoice, Payment)
#	model_id

	title
	description
	status
	assignee	--> users
	created_at
	updated_at
	assigned_at
	closed_at
	
	alert_notification_ids # array / serialized

# comments
- https://github.com/lml/commontator

# notifications

	id
	user_id
	type	[:new_ticket, :new_assignment, :new_invoice, :new_payment, :new_order, :new_item, :new_supplier_order, :new_shipment, :new_user, :new_comment]
	model_type	(Ticket, Comment, Order, Item, Supplier, User, Invoice, Payment, Shipment)
	model_id
	# type
	
	
	new_notification(user, type, model)	<--- call back at every model when create first time, or update certain field
	
	in each.controller
	
		check_notification
		
			based on action = show --> delete notification of same model, all types, current_user
		




Sideqik
===========================================================================================


whenever
===========================================================================================


