whenever
===========================================================================================

Concepts





delayed_job
===========================================================================================

# https://github.com/collectiveidea/delayed_job#installation

	gem 'delayed_job_active_record'
	gem "daemons"

	rails generate delayed_job:active_record
	rails db:migrate

# config/application.rb

	config.active_job.queue_adapter = :delayed_job

# config/initializers/delayed_job_config.rb
 
	Delayed::Worker.destroy_failed_jobs = false
	Delayed::Worker.sleep_delay = 60
	Delayed::Worker.max_attempts = 3
	Delayed::Worker.max_run_time = 5.minutes
	Delayed::Worker.read_ahead = 10
	Delayed::Worker.default_queue_name = 'default'
	Delayed::Worker.delay_jobs = !Rails.env.test?
	Delayed::Worker.raise_signal_exceptions = :term
	Delayed::Worker.logger = Logger.new(File.join(Rails.root, 'log', 'delayed_job.log'))
 

# This will create guests_cleanup_job.rb in jobs folder

	rails generate job guests_cleanup

# guests_cleanup_job.rb

	class GuestsCleanupJob < ActiveJob::Base
	  queue_as :default

	  def perform(*args)
		# Do something later
		# here you can call instant methods of passed objects (models) that performs long processing
		# args will include whatever object you pass for processing
		
		args.each do |arg|
			puts arg.class	# in the next example, it will print: Team, String
		end
		
	  end
	end
	
# For example

	model = Team.find_by_name("Red Star")
	GuestsCleanupJob.perform_later(model, "hello")

# Adding a Task to the Queue can be performed in many way .. .

	- GuestsCleanupJob.perform_later(model, "hello")	
	- GuestsCleanupJob.set(wait: 10.seconds).perform_later(model)
	- GuestsCleanupJob.delay(run_at: 5.seconds.from_now).perform_later("something")
	- GuestsCleanupJob.delay(run_at: 5.seconds.from_now).perform_now("something")

# So Jobs can be A job class, or a function in any model

	# without delayed_job
	@user.activate!(@device)

	# with delayed_job
	@user.delay.activate!(@device)

	# without delayed_job
	Notifier.signup(@user).deliver

	# with delayed_job
	Notifier.delay.signup(@user)

	# delayed_job running at a specific time
	Notifier.delay(run_at: 5.minutes.from_now).signup(@user)

	# when using parameters, the .with method must be called before the .delay method
	Notifier.with(foo: 1, bar: 2).delay.signup(@user)

# Or from any class (service maybe)

	class LongTasks
		def send_mailer
			# Some other code
		end
		...
		
		handle_asynchronously :send_mailer, :priority => 20
		handle_asynchronously :in_the_future, :run_at => Proc.new { 5.minutes.from_now }
		.....		
	end


# You can create custom jobs as following

	NewsletterJob = Struct.new(:text, :emails) do
		def perform
			emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
		end
	  
	  	# Override	  
		def max_attempts
			3
		end

		def max_run_time
			120 # seconds
		end

		def destroy_failed_jobs?
			false
		end

		def queue_name
		'newsletter_queue'
		end

		def reschedule_at(current_time, attempts)
			current_time + 5.seconds
		end	  
	end

	Delayed::Job.enqueue NewsletterJob.new('lorem ipsum...', Customers.pluck(:email))
	
# Hooks

	class ParanoidNewsletterJob < NewsletterJob
	  def enqueue(job)
		record_stat 'newsletter_job/enqueue'
	  end

	  def perform
		emails.each { |e| NewsletterMailer.deliver_text_to_email(text, e) }
	  end

	  def before(job)
		record_stat 'newsletter_job/start'
	  end

	  def after(job)
		record_stat 'newsletter_job/after'
	  end

	  def success(job)
		record_stat 'newsletter_job/success'
	  end

	  def error(job, exception)
		Airbrake.notify(exception)
	  end

	  def failure(job)
		page_sysadmin_in_the_middle_of_the_night
	  end
	end		
	
# Notice

On error, the job is scheduled again in 5 seconds + N ** 4, where N is the number of attempts or using the job's defined reschedule_at method.
The default Worker.max_attempts is 25. After this, the job is either deleted (default), or left in the database with "failed_at" set. With the default of 25 attempts, the last retry will be 20 days later, with the last interval being almost 100 hours.
The default Worker.max_run_time is 4.hours. If your job takes longer than that, another computer could pick it up. It's up to you to make sure your job doesn't exceed this time. You should set this to the longest time you think the job could take.


# To run the workers

	rake jobs:work		# self running, Ctl^C to exit
	rake jobs:workoff 	# run all jobs and exit
	rake jobs:clear 	# clean all jobs

	# run as  daemon
		
	RAILS_ENV=production bin/delayed_job start
	RAILS_ENV=production bin/delayed_job stop

	# Runs two workers in separate processes.
	RAILS_ENV=production bin/delayed_job -n 2 start
	RAILS_ENV=production bin/delayed_job stop

	# Set the --queue or --queues option to work from a particular queue.
	RAILS_ENV=production bin/delayed_job --queue=tracking start
	RAILS_ENV=production bin/delayed_job --queues=mailers,tasks start

	# Use the --pool option to specify a worker pool. You can use this option multiple times to start different numbers of workers for different queues.
	# The following command will start 1 worker for the tracking queue,
	# 2 workers for the mailers and tasks queues, and 2 workers for any jobs:
	RAILS_ENV=production bin/delayed_job --pool=tracking --pool=mailers,tasks:2 --pool=*:2 start

	# Runs all available jobs and then exits
	RAILS_ENV=production bin/delayed_job start --exit-on-complete
	# or to run in the foreground
	RAILS_ENV=production bin/delayed_job run --exit-on-complete

	# Restart
	RAILS_ENV=production bin/delayed_job restart
	RAILS_ENV=production bin/delayed_job -n2 restart

# Remember, to install daemons in order to use bin/delayed_job as a daemon.

	gem "daemons"
	

# table delayed_jobs in details

	create_table :delayed_jobs, :force => true do |table|
	  table.integer  :priority, :default => 0      # Allows some jobs to jump to the front of the queue
	  table.integer  :attempts, :default => 0      # Provides for retries, but still fail eventually.
	  table.text     :handler                      # YAML-encoded string of the object that will do work
	  table.text     :last_error                   # reason for last failure (See Note below)
	  table.datetime :run_at                       # When to run. Could be Time.zone.now for immediately, or sometime in the future.
	  table.datetime :locked_at                    # Set when a client is working on this object
	  table.datetime :failed_at                    # Set when all retries have failed (actually, by default, the record is deleted instead)
	  table.string   :locked_by                    # Who is working on this object (if locked)
	  table.string   :queue                        # The name of the queue this job is in
	  table.timestamps

	  table.cron	# added & used by cron job	
	end

# Cron jobs
-------------------
# You need to install 

	gem 'delayed_cron_job', '0.7.2'
	
	# create migration since we are using active record
	rails generate delayed_job:cron	
	rake db:migrate
	
# How to use

	Delayed::Job.enqueue(GuestsCleanupJob.new, cron: '* * * * *')	# every minute

# You may use the id of the Delayed::Job as returned by the #enqueue method to reference and/or remove the scheduled job in the future.
# Job must be PORO in case of croned jobs, no need to extend ActiveJob::Base

	class GuestsCleanupJob #< ActiveJob::Base
	  # queue_as :default
	  def perform(*args)
		# Do something later
		# logger.info "================================================="
		item = Item.first
		args.each do |p|
		  # logger.info p.class
		end
	  end
	end

# when create (enqueue) a job, try to get it's object 

	job = Delayed::Job.enqueue(GuestsCleanupJob.new, cron: '* * * * *')

	# you can get it's id, name .. etc
	job.id
	
	# you can 
	Delayed::Job.all
	obj = 	Delayed::Job.find(id)
	obj.destroy


# references
- https://github.com/ejschmitt/delayed_job_web
- https://github.com/javan/whenever
- https://crontab.guru/every-1-minute
- https://github.com/codez/delayed_cron_job/tree/v0.6.0
- https://davidmles.medium.com/a-quick-look-at-background-jobs-in-ruby-43e6176aeee5
- https://github.com/collectiveidea/delayed_job#installation


- text tables
	https://github.com/matt-harvey/tabulo
	
- machine learning 
	https://medium.com/devtechtoday/ruby-on-rails-in-machine-learning-artificial-intelligence-yay-or-nay-eb63db832f2a
	
- ransack 
	https://github.com/activerecord-hackery/ransack
	
- https://firrae.medium.com/wsl2-ruby-on-rails-and-development-performance-6a36e40bd38b
- https://www.hackerrank.com/challenges/ruby-methods-introduction/problem?utm_campaign=challenge-recommendation&utm_medium=email&utm_source=24-hour-campaign&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen&h_r=next-challenge&h_v=zen
- hot wire
	https://gorails.com/episodes/hotwire-rails
	

# create another table to manage jobs (CRUD) jobs

	id
	name	# entered by user
	job_id	# job id	--> delayed_job_id --|
	description
	status
	created_at
	updated_at
	alert_id		<----		added
	every
	action
	template_id					--> templates: name, template
	group_by	'supplier_order_id'
	
	
  E_E =     {
    "Every 1 hour" => "0 * * * *",
    "Every 1 day" => "0 1 * * *",
    "Every 1 month" => "0 0 * * *",
    "Every 1 week" => "0 0 * * 0"
  }

actions:

  ACTIONS =     {
    "Send Customer E-mail" => "send_customer_email",
    "Send Ticket" => "send_ticket",
    "Notify Admin" => "notify_admin",
  }

  enum status: [:active, :paused]


# alerts

	id
	name
	query
	model
	
	
# alert_notifications

	alert_id
	model_type	(Order, Item, Supplier, User, Invoice, Payment)
	model_id
	
	action	# taken from trigger job 	
	status	[:ready, :done, :failed]
	

# templates

	name		string	<----- 
	template	text	(erb)
		
# tickets ..... 

	id
	ticket_type_id	--> ticket_types

#	model_type	(Order, Item, Supplier, User, Invoice, Payment)
#	model_id

	title
	description
	status
	assignee	--> users
	created_at
	updated_at
	assigned_at
	closed_at
	
	alert_notification_ids # array / serialized

# comments
- https://github.com/lml/commontator

# notifications

	id
	user_id
	type	[:new_ticket, :new_assignment, :new_invoice, :new_payment, :new_order, :new_item, :new_supplier_order, :new_shipment, :new_user, :new_comment]
	model_type	(Ticket, Comment, Order, Item, Supplier, User, Invoice, Payment, Shipment)
	model_id
	# type
	
	
	new_notification(user, type, model)	<--- call back at every model when create first time, or update certain field
	
	in each.controller
	
		check_notification
		
			based on action = show --> delete notification of same model, all types, current_user
		




Sideqik
===========================================================================================

===========================================================================================
