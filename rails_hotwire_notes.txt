Hotewire
=========================================================================


channels (action cable)
========================================================================

> rails g channel room

app/channels
├── application_cable
│   ├── channel.rb		*
│   └── connection.rb	*
└── room_channel.rb <----------


app/javascript/channels
├── consumer.js
├── index.js
└── room_channel.js	<----------

Now, 

channel.rb:

	module ApplicationCable
	  class Channel < ActionCable::Channel::Base
	  end
	end

connection.rb:

module ApplicationCable

  class Connection < ActionCable::Connection::Base
    identified_by :current_user
    def connect
      logger.info "========================== connected"
      # logger.info env['warden'].user.id
      self.current_user = find_verified_user		<-- used with devise
      logger.add_tags 'ActionCable', current_user.id
    end

    protected

    def find_verified_user # this checks whether a user is authenticated with devise
      if verified_user = env['warden'].user
        verified_user
      else
        reject_unauthorized_connection
      end
    end
  end
end

room_channel.rb:

	class RoomChannel < ApplicationCable::Channel
	  def subscribed
		stream_from "room_channel"		<-----------------
	  end

	  def unsubscribed
		# Any cleanup needed when channel is unsubscribed
	  end
	end

----

room_channel.js:

	import consumer from "./consumer"

	consumer.subscriptions.create("RoomChannel", {
	  connected() {
		// Called when the subscription is ready for use on the server
		console.log("connected")
	  },

	  disconnected() {
		// Called when the subscription has been terminated by the server
	  },

	  received(data) {
		// Called when there's incoming data on the websocket for this channel
	  }
	});


- From anywhere in rails, do

    ActionCable.server.broadcast "room_channel", message: "helllo"

# This will be captured inside room_channel.js:

	received(data) {
		// Called when there's incoming data on the websocket for this channel
		
		--> data['message']
	}

- To send a message from client to server (channel).

    consumer.send({
		command: 'message', data: JSON.stringify({	
			message: 'This is a cool chat app.'
		}), 
		identifier: JSON.stringify({
			channel: "RoomChannel"
		})
	});



Stimulus
========================================================================

# After setting up your rails with stimulus (Rails 7 by defualt)
- You need to know that Turbolinks and UJS Replaced by Turbo and Stimulus


	├── application.js
	├── controllers
	│   ├── application.js
	│   ├── hello_controller.js
	│   └── index.js
	└── lib.js	// ignore

	application.js:
	
		// Entry point for the build script in your package.json
		import "@hotwired/turbo-rails"
		import "./controllers"
	
		# add this to capture whenever turbolink is loaded
		# check other events
		# with jQuery
		$(document).on('turbo:load', function() {})	
		
		# Or vanilla
		document.addEventListener("turbo:before-cache", function() {})
		document.addEventListener("turbo:load", function() {})
	
	
	controllers/index.js
	
		// This file is auto-generated by ./bin/rails stimulus:manifest:update
		// Run that command whenever you add a new controller or create them with
		// ./bin/rails generate stimulus controllerName

		import { application } from "./application"

		import HelloController from "./hello_controller"
		application.register("hello", HelloController);

	controllers/application.js

		import { Application } from "@hotwired/stimulus"

		const application = Application.start()

		// Configure Stimulus development experience
		application.debug = false
		window.Stimulus   = application

		export { application }

	controllers/hello_controller.js
			
		import { Controller } from "@hotwired/stimulus"

		export default class extends Controller {
		  connect() {
			this.element.textContent = "Hello World!"	// this will replace everything inside the controller element
		  }
		}


- create a new controller. app/javascript/controllers/demo_controller.js:

	import { Controller } from "@hotwired/stimulus"

	export default class extends Controller {
		connect() {
			this.element.textContent = "Hello World!"
		}
	  
		# conditional loading .. return true to load
		static get shouldLoad() {
			return true;	// false
		}
	}
	
	- this includes a list of properties to be used
	
		this.application		-> stimulus application instance
		this.element			-> html element and therefor you can read the id
		this.element.dataset	-> to read values of data-id="1" as this.element.dataset.id
		this.element.value		-> to read the value of element (input field)
	

- Register the controller in index.js

	import DemoController from "./demo_controller"
	application.register("demo", DemoController);
	
	# If you use Stimulus for Rails with an import map or Webpack together with the @hotwired/stimulus-webpack-helpers package, 
	your application will automatically load and register controller classes following the conventions above.
	# In our case (esbuild) If not, your application must manually load and register each controller class.

- View

	<div id="1" data-id="1" data-controller="demo">
	</div>

	# You can have as many views you want in the same page, all will be activated by the same controller
	# check for which element
	
		connect() {
			this.element.dataset.id	--> 1
		
			const element = this.element;
			const data = element.dataset;
			const id = element.id	# this is possible if used id=""

			if (data.id == 1) {
			  element.textContent = "Hello 1"
			} else {
			  element.textContent = "Hello 2"
			}
		}



- Controllers


	# identifiers naming
		
		controllers/demo_controller.js -> data-controller="demo"
		
		clipboard_controller.js 		clipboard
		date_picker_controller.js 		date-picker
		users/list_item_controller.js 	users--list-item	<-----
		local-time-controller.js 		local-time	

	# scope

		# Everything inside this div within the scope of controller including the parent
		<div data-id="1" data-controller="demo">	
			<h1>Hello</h1>	
		</div>

		# nested
		<ul id="parent" data-controller="list">
		  <li data-list-target="item">One</li>
		  <li>
			<ul id="child" data-controller="list">
			  <li data-list-target="item">I am</li>			<------ not part of parent scope
			</ul>
		  </li>
		</ul>	

		# you can have multiple controllers, also you can have multiple elements on the page reference to the same controller
		<div data-controller="clipboard list-item"></div>
		
	# cross controllers communications

		# The Controller class has a convenience method called (dispatch)
		# Both controllers need to be set on the same view (scope)

		class ClipboardController extends Controller {
		  static targets = [ "source" ]

		  copy() {
			  
			# dispatch event called "copy" 
			# with payload in detail: { content: this.sourceTarget.value }
			this.dispatch("copy", { target: document, detail: { content: this.sourceTarget.value } })			--> read the value in input field 
																							--> <input data-clipboard-target="source" type="text" value="1234" readonly>		
			this.sourceTarget.select()
			document.execCommand("copy")	<-- execute the command dispatch copy
		  }
		}
		
		class EffectsController extends Controller {
		  flash({ detail: { content } }) {
			// e.detail.content
			// e.target	-----> the sender element	(clipboard) .. tyou can pass document { target: document, detail: { content: this.sourceTarget.value } }
			// e.params
			// e.type	-----> clipboard:copy
			
			console.log(content) // 1234
		  }
		}

		<div data-controller="clipboard effects" data-action="clipboard:copy->effects#flash">	2 --> this will call flash method once clipboard.copy id dispatched !!
		  PIN: <input data-clipboard-target="source" type="text" value="1234" readonly>
		  <button data-action="clipboard#copy">Copy to Clipboard</button>						1 --> this will invoke method copy()
		</div>
		
		# For distant controllers / views use @document
		
		data-action="clipboard:copy@document->effects#flash"	
		


	# Directly Invoking Other Controllers

		class MyController extends Controller {
		  static targets = [ "other" ]							 

		  copy() {
			const otherController = this.application.getControllerForElementAndIdentifier(this.otherTarget, 'other')
			otherController.otherMethod()	
		  }
		}	
		
		
	# a batter way 
	
	export default class extends Controller {
		connect () {
			this.element[this.identifier] = this
		}

		name () {
			this.element.innerHTML = `I am ${this.element.dataset.name}.`
		}
	}

	// index.html
	<div id="person" data-controller="test" data-name="Steve"></div>
		
	// run this in your console
	document.querySelector('#person').test.name()
	
		
	# https://www.betterstimulus.com/interaction/controller-dom-mapper.html


	** be aware of the  Turbolinks’ preview cache
	*********************************************
	[D]uring standard navigation (via Application Visits), Turbolinks will immediately restore the page from cache and display it as a preview while simultaneously loading a fresh copy from the network. This gives the illusion of instantaneous page loads for frequently accessed locations.

	when dealing with action generated from a link with href="#" .. use in action fun:
	
		event.preventDefault()


	# Callbacks

		initialize() 								Once, when the controller is first instantiated
		[name]TargetConnected(target: Element) 		Anytime a target is connected to the DOM
		connect() 									Anytime the controller is connected to the DOM
		[name]TargetDisconnected(target: Element) 	Anytime a target is disconnected from the DOM
		disconnect() 								Anytime the controller is disconnected from the DOM


		- So if you have
		
			static targets = [ "name", "output" ]		-->		<input data-hello-target="name" type="text">
															<h2 data-hello-target="output"></h2>
		This will be called:
		
			nameTargetConnected(e) {
				console.log("name ......... connected");
				e.value = "45"	// initial value
			}
		
	# Params (within controller)
	
		<div data-controller="demo" data-id="1" data-demo-page="1" data-demo-some-param="3" data-id="1">
		
		# can be captured
		
			this.element.dataset.id
			this.element.dataset.demoPage
			this.element.dataset.demoSomeParam
		
		
	# state
	
		<div data-controller="slideshow" data-index="1">
		
		initialize() {
			this.index = Number(this.element.dataset.index)	// whatever variable
		}	
		
		# you can use values
				
		
- Actions

	# view
	<div data-controller="gallery">
		<button data-action="click->gallery#next">…</button>
	</div>
	
	# gallery_controller.js
	next(event) {
		// …
		// event.type 	The name of the event (e.g. "click")
		// event.target 	The target that dispatched the event (i.e. the innermost element that was clicked)
		// event.currentTarget 	The target on which the event listener is installed (either the element with the data-action attribute, or document or window)
		// event.params 	The action params passed by the action submitter element
		
		// event.preventDefault() 	Cancels the event’s default behavior (e.g. following a link or submitting a form)
		// event.stopPropagation() 	Stops the event before it bubbles up to other listeners on parent elements
		
		// event.stopImmediatePropagation()	This will ignore any further actions (multiple actions)
	}

	# click here can be removed for certain element to use the default
	
		click->gallery#next	
	
	# defaults
	
		a 					click
		button 				click
		details				toggle	// what is this ?
		form 				submit
		input 				input
		input type=submit 	click
		select 				change
		textarea 			input
		
	# Global Events
	# You can append @window or @document to the event name in an action descriptor to install the event listener on window or document
		
		data-action="resize@window->gallery#layout"
		
	# options
	# check https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters
	
		data-action="scroll->gallery#layout:!passive"
		
		:capture 	{ capture: true }
		:once 	{ once: true }
		:passive 	{ passive: true }
		:!passive 	{ passive: false }

	# you can have multiple actions
	
		<input type="text" data-action="focus->field#highlight input->search#update">

	# Params - How to read params from events
	
		<div data-controller="demo" data-demo-some-param="3" data-id="1">	--> e.params.some
	
		data-[controller]-id-param="12345" 						123 		Number
		data-[controller]-url-param="/votes" 					"/votes" 	String
		data-[controller]-payload-param='{"value":"1234567"}' 	{ value: 1234567 } 	Object
		data-[controller]-active-param="true" 					true 	Boolean

		# from controller
		func(e) {
			e.params.url	--> "/votes" 
		}
	
		# shortcut to read only params from event
		upvote({ params }) {
		  // { id: 12345, url: "/votes", active: true, payload: { value: 1234567 } }
		  console.log(params) 
		}		
	
		upvote({ params: { id, url } }) {
		  console.log(id) // 12345
		  console.log(url) // "/votes"
		}


- Targets
	
	# https://www.npmjs.com/package/stimulus-data-bindings

	<input type="text" data-search-target="query">
	
	# to read it from controller
	
		const tragets = ['search']
		...		
		this.searchTarget
	
	# As 
	
		Kind 		Name 					Value
		---------------------------------------------------------------------
		Singular 	this.[name]Target 		The first matching target in scope
		Plural 		this.[name]Targets 		An array of all matching targets in scope
		Existential this.has[Name]Target 	A boolean indicating whether there is a matching target in scope
											# if (this.hasResultsTarget) { this.resultsTarget.innerHTML = "…"}

	# properites
	
		this.searchTarget.textContent
		this.searchTarget.value
		
		# Yes since the target here is an HTML element .. 

	# Shared Targets
	
		<form data-controller="search checkbox">
		  <input type="checkbox" data-search-target="projects" data-checkbox-target="input">
		  <input type="checkbox" data-search-target="messages" data-checkbox-target="input">
		  …
		</form>		

		# Inside the checkbox controller, this.inputTargets returns an array with both checkboxes.

- Values

	# Example

		<div id="1" data-id="1" data-demo-url-value="/messages" data-controller="demo">
		</div>

	# You can have as many views you want in the same page, all will be activated by the same controller
	# check for which element
	
		static values = {
			url: String			--> this will read data-demo-url-value
									# contentType --> data-demo-content-type-value 
		}

		connect() {
			// this.element.dataset.id	--> 1
			fetch(this.urlValue).then(/* … */)
		}	
	
	# definition
	
		static values = {
			url: String,	// OR 	url: { type: String, default: '/bill' },
			interval: Number,
			params: Object
		  }	

	# types
	
		Array 		JSON.stringify(array) 	JSON.parse(value						[]
		Boolean 	boolean.toString() 		!(value == "0" || value == "false")		false
		Number 		number.toString() 		Number(value)							0
		Object 		JSON.stringify(object) 	JSON.parse(value)						{}
		String 		Itself 					Itself									""

	﹟Properties and Attributes

		Getter 		this.[name]Value 		Reads data-[identifier]-[name]-value
		Setter 		this.[name]Value= 		Writes data-[identifier]-[name]-value
		Existential this.has[Name]Value 	Tests for data-[identifier]-[name]-value

	# Callbacks
	
		export default class extends Controller {
		  static values = { url: String }

		  urlValueChanged(value, previousValue) {
			/* … */
		  }
		}


- Working With External Resources

	# fetch

		<div data-controller="content-loader"
		 data-content-loader-url-value="/messages.html"></div>

		fetch(this.urlValue)
		  .then(response => response.text())
		  .then(html => this.element.innerHTML = html)

		# to read json 
		<div data-controller="content-loader"
		 data-content-loader-url-value="/messages.json"></div>
		
		fetch(this.urlValue)
		  .then(response => response.json())
		  .then(data => {
			console.log(data);
		  })
	
	# releasing resources
	# you might run some interval to reload certain data every certain time

		connect() {
			this.refreshTimer = startRefreshing() {
				setInterval(() => {
				  this.load()
				}, this.refreshIntervalValue)
			}
		}
	
		disconnect() {
			if (this.refreshTimer) {
			  clearInterval(this.refreshTimer)
			}
		}



Good references
# https://www.betterstimulus.com/




Turbo
========================================================================
# Turbo bundles several techniques for creating fast, modern, progressively enhanced web applications without using much JavaScript.

# all the logic in front-end

# With Turbo, you let the server deliver HTML directly, which means all the logic for checking permissions, interacting directly with your domain model, and everything else that goes into programming an application can happen more or less exclusively within your favorite programming language.


# https://github.com/jasonfb/hot-glue

- Drive

	



























CableReady
========================================================================

- CableReady is a Ruby gem that was first released in May 2017. 
- It lets you create great real-time user experiences by triggering client-side DOM changes, events and notifications over ActionCable web sockets. 
- These commands are called operations.
- You can broadcast one or many operations at once from inside a Reflex, as well as:
	
	- ActiveRecord callbacks, 
	- ActiveJobs, 
	- ActionCable Channels, 
	- controller actions, 
	- rake tasks and in response to API calls and webhooks.

- Other CableReady Tools

	- https://optimism.leastbad.com/
	- https://github.com/stimulusreflex/futurism	--> part of StimilusReflex



* Stimulus reflex
========================================================================
- Check Stimilus https://docs.stimulusreflex.com/quickstart
- https://devhints.io/stimulus-reflex

# For new projects

	rails new myproject --webpack=stimulus
	cd myproject

# For existing projects

	bundle exec rails webpacker:install:stimulus

# For both project types

	> bundle add stimulus_reflex
	> bundle exec rails stimulus_reflex:install
	
	# latest
	bundle add stimulus_reflex --version 3.5.0.pre8
	rake stimulus_reflex:install

# StimulusReflex requires Redis to be

	app/reflexes/
	├── application_reflex.rb
	├── counter_reflex.rb	<--------------
	└── example_reflex.rb


Any page:

	<a href="#"
	   data-reflex="click->Counter#increment"
	   data-step="1"
	   data-count="<%= @count.to_i %>"
	>Increment <%= @count.to_i %></a>

app/reflexes/counter_reflex.rb:

	class CounterReflex < ApplicationReflex
	  def increment
		@count = element.dataset[:count].to_i + element.dataset[:step].to_i
		# ActionCable.server.broadcast "room_channel", message: @count.to_s
		# morph "#messages", @count #render(partial: "path/to/foo")	<- decide which block#html and what data to render (even partials)
	  end
	end


- Using Stimilus.js Controller

	<!-- index.html.erb -->
	<a href="#"
	  data-controller="counter"
	  data-action="click->counter#increment"
	>Increment <%= @count %></a>
	
// counter_controller.js

	import { Controller } from 'stimulus'
	import StimulusReflex from 'stimulus_reflex'

	export default class extends Controller {
	  connect() {
		StimulusReflex.register(this)
	  }

	  increment(event) {
		event.preventDefault()
		this.stimulate('Counter#increment', 1)
	  }
	}

# counter_reflex.rb

	class CounterReflex < StimulusReflex::Reflex
	  def increment(step = 1)
		session[:count] = session[:count].to_i + step
	   end
	end

- morpth a certain selected div
- morth :nothing
- render the whole pa

The full page (default)				Yes		~50ms
All children of a CSS DOM selector	No		~15ms
Nothing at all						No		~6ms

Scoping Page Morphs

	data-reflex-root=".class, #id, [attribute]"

	<div data-reflex-root="[forward],[backward]">
	  <input type="text" value="<%= @words %>" data-reflex="keyup->Example#words">
	  <div forward><%= @words %></div>
	  <div backward><%= @words&.reverse %></div>
	</div>

Permanent Elements

	<div data-reflex-permanent>
	  <iframe src="https://ghbtns.com/github-btn.html?user=stimulusreflex&repo=stimulus_reflex&type=star&count=true" frameborder="0" scrolling="0" class="ghbtn"></iframe>
	  <iframe src="https://ghbtns.com/github-btn.html?user=stimulusreflex&repo=stimulus_reflex&type=fork&count=true" frameborder="0" scrolling="0" class="ghbtn"></iframe>
	</div>

Selector Morphs

	<header data-reflex="click->Example#change">
	  <div id="foo">
		<span class="spa"><%= message %></span>
	  </div>
	</header>

	class ExampleReflex < ApplicationReflex
	  def change
		morph "#foo", "Your muscles... they are so tight."
	  end
	end

Intelligent defaults

	yelling = element.value.upcase
	morph "#foo", render(partial: "path/to/foo", locals: {message: yelling})

	
- https://dev.to/phawk/hotwire-best-practices-for-stimulus-40e





Notes to activate Reflex on Rails 7 with Stimilus / esbuild
---------------------------------------------------------------------------------







ViewComponent
==================================================================================
# https://viewcomponent.org/

- A framework for creating reusable, testable & encapsulated view components, built to integrate seamlessly with Ruby on Rails.
- So, instead of building partials with direct database access for reusability !


	# app/components/message_component.rb
	class MessageComponent < ViewComponent::Base
	  def initialize(name:)
		@name = name
	  end
	end

	<%# app/components/message_component.html.erb %>
	<h1>Hello, <%= @name %>!</h1>

Which is rendered by calling:

	<%# app/views/demo/index.html.erb %>
	<%= render(MessageComponent.new(name: "World")) %>


* StimilusReflex is using ViewComponent
# https://viewcomponent.org/resources.html
# https://primer.style/view-components/components/menu#url

#* https://github.com/joshleblanc/view_component_reflex
