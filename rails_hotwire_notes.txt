Hotewire
=========================================================================


channels (action cable)
========================================================================

> rails g channel room

app/channels
├── application_cable
│   ├── channel.rb		*
│   └── connection.rb	*
└── room_channel.rb <----------


app/javascript/channels
├── consumer.js
├── index.js
└── room_channel.js	<----------

Now, 

channel.rb:

	module ApplicationCable
	  class Channel < ActionCable::Channel::Base
	  end
	end

connection.rb:

module ApplicationCable

  class Connection < ActionCable::Connection::Base
    identified_by :current_user
    def connect
      logger.info "========================== connected"
      # logger.info env['warden'].user.id
      self.current_user = find_verified_user		<-- used with devise
      logger.add_tags 'ActionCable', current_user.id
    end

    protected

    def find_verified_user # this checks whether a user is authenticated with devise
      if verified_user = env['warden'].user
        verified_user
      else
        reject_unauthorized_connection
      end
    end
  end
end

room_channel.rb:

	class RoomChannel < ApplicationCable::Channel
	  def subscribed
		stream_from "room_channel"		<-----------------
	  end

	  def unsubscribed
		# Any cleanup needed when channel is unsubscribed
	  end
	end

----

room_channel.js:

	import consumer from "./consumer"

	consumer.subscriptions.create("RoomChannel", {
	  connected() {
		// Called when the subscription is ready for use on the server
		console.log("connected")
	  },

	  disconnected() {
		// Called when the subscription has been terminated by the server
	  },

	  received(data) {
		// Called when there's incoming data on the websocket for this channel
	  }
	});


- From anywhere in rails, do

    ActionCable.server.broadcast "room_channel", message: "helllo"

# This will be captured inside room_channel.js:

	received(data) {
		// Called when there's incoming data on the websocket for this channel
		
		--> data['message']
	}

- To send a message from client to server (channel).

    consumer.send({
		command: 'message', data: JSON.stringify({	
			message: 'This is a cool chat app.'
		}), 
		identifier: JSON.stringify({
			channel: "RoomChannel"
		})
	});




this.$root.cable.connection.isOpen()
consumer.connection.open()

$(document).on('turbolinks:load', function() {})




Stimulus
========================================================================







Turbo
========================================================================







* Stimulus reflex
========================================================================
- 
- Check Stimilus https://docs.stimulusreflex.com/quickstart
- https://devhints.io/stimulus-reflex

# For new projects

	rails new myproject --webpack=stimulus
	cd myproject

# For existing projects

	bundle exec rails webpacker:install:stimulus

# For both project types

	bundle add stimulus_reflex
	bundle exec rails stimulus_reflex:install

----

> bundle add stimulus_reflex
> bundle exec rails stimulus_reflex:install

app/reflexes/
├── application_reflex.rb
├── counter_reflex.rb	<--------------
└── example_reflex.rb


Any page:

	<a href="#"
	   data-reflex="click->Counter#increment"
	   data-step="1"
	   data-count="<%= @count.to_i %>"
	>Increment <%= @count.to_i %></a>

app/reflexes/counter_reflex.rb:

	class CounterReflex < ApplicationReflex
	  def increment
		@count = element.dataset[:count].to_i + element.dataset[:step].to_i
		# ActionCable.server.broadcast "room_channel", message: @count.to_s
		# morph "#messages", @count #render(partial: "path/to/foo")	<- decide which block#html and what data to render (even partials)
	  end
	end


- Using Stimilus.js Controller

	<!-- index.html.erb -->
	<a href="#"
	  data-controller="counter"
	  data-action="click->counter#increment"
	>Increment <%= @count %></a>
	
// counter_controller.js

	import { Controller } from 'stimulus'
	import StimulusReflex from 'stimulus_reflex'

	export default class extends Controller {
	  connect() {
		StimulusReflex.register(this)
	  }

	  increment(event) {
		event.preventDefault()
		this.stimulate('Counter#increment', 1)
	  }
	}

# counter_reflex.rb

	class CounterReflex < StimulusReflex::Reflex
	  def increment(step = 1)
		session[:count] = session[:count].to_i + step
	   end
	end

- morpth a certain selected div
- morth :nothing
- render the whole pa

The full page (default)				Yes		~50ms
All children of a CSS DOM selector	No		~15ms
Nothing at all						No		~6ms

Scoping Page Morphs

	data-reflex-root=".class, #id, [attribute]"

	<div data-reflex-root="[forward],[backward]">
	  <input type="text" value="<%= @words %>" data-reflex="keyup->Example#words">
	  <div forward><%= @words %></div>
	  <div backward><%= @words&.reverse %></div>
	</div>

Permanent Elements

	<div data-reflex-permanent>
	  <iframe src="https://ghbtns.com/github-btn.html?user=stimulusreflex&repo=stimulus_reflex&type=star&count=true" frameborder="0" scrolling="0" class="ghbtn"></iframe>
	  <iframe src="https://ghbtns.com/github-btn.html?user=stimulusreflex&repo=stimulus_reflex&type=fork&count=true" frameborder="0" scrolling="0" class="ghbtn"></iframe>
	</div>

Selector Morphs

	<header data-reflex="click->Example#change">
	  <div id="foo">
		<span class="spa"><%= message %></span>
	  </div>
	</header>

	class ExampleReflex < ApplicationReflex
	  def change
		morph "#foo", "Your muscles... they are so tight."
	  end
	end

Intelligent defaults

	yelling = element.value.upcase
	morph "#foo", render(partial: "path/to/foo", locals: {message: yelling})

	
- https://dev.to/phawk/hotwire-best-practices-for-stimulus-40e







ViewComponent
-------------
# https://viewcomponent.org/

- A framework for creating reusable, testable & encapsulated view components, built to integrate seamlessly with Ruby on Rails.
- So, instead of building partials with direct database access for reusability !


	# app/components/message_component.rb
	class MessageComponent < ViewComponent::Base
	  def initialize(name:)
		@name = name
	  end
	end

	<%# app/components/message_component.html.erb %>
	<h1>Hello, <%= @name %>!</h1>

Which is rendered by calling:

	<%# app/views/demo/index.html.erb %>
	<%= render(MessageComponent.new(name: "World")) %>


* StimilusReflex is using ViewComponent
# https://viewcomponent.org/resources.html
# https://primer.style/view-components/components/menu#url

#* https://github.com/joshleblanc/view_component_reflex
