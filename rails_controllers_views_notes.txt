Controllers & Views
==========================================================================================

# https://guides.rubyonrails.org/
# https://guides.rubyonrails.org/action_controller_overview.html

Controllers
------------------------------------------------------------------------
- Generator

	# generate mode /controller/helpers and views
	
	rails g scaffold Project
	rails g scaffold Project title:string body:text

	# generate controller/helpers and views from model

	rails g scaffold_controller [model] // generate without fields
	rails g scaffold_controller [model]  title:string body:text // generate with fields

	rails g controller home 		--> home_controller.rb (HomeController)
	rails g controller home index 	--> home_controller.rb (HomeController) + views/home/index.html.erb

- To check available generators

	rails g --help

- General
------------------------------------------------------------------------

	- params is where the data 
	- params is Hash


	- Controller for model Article

	def show
	  @article = Article.find(params[:id])
	end

	def new
		@article = Article.new	--> to be used by teh form
	end

	def create
		@item = Item.new(item_params)
		.....
	end

	def index
	  @articles = case params[:order_by]
		when 'title'     then Article.order('title')
		when 'published' then Article.order('created_at DESC')
		else                  Article.all
	  end
	end

	private

    def item_params
      params.fetch(:item, {}).permit(:name, :id, :title, :summary, :body, :type, :status, :user_id, :info, :reference_id, :tags)	<------ control what params allowed to pass
    end


- Request / Response Objects (reading from controller)
------------------------------------------------------------------------

- request

	# namespace / scope cna be used in saas to set which scope (username, servicename .. etc) to run the controller actions within 
	# to detect which scope or namespace from controller

	host 			The hostname used for this request.
	domain(n=2) 	The hostname's first n segments, starting from the right (the TLD).
	format 			The content type requested by the client.
	method 			The HTTP method used for the request.
	get?, post?, patch?, put?, delete?, head? 	Returns true if the HTTP method is GET/POST/PATCH/PUT/DELETE/HEAD.
	headers 		Returns a hash containing the headers associated with the request.
	port 			The port number (integer) used for the request.
	protocol 		Returns a string containing the protocol used plus "://", for example "http://".
	query_string 	The query string part of the URL, i.e., everything after "?".
	remote_ip 		The IP address of the client.
	url 			The entire URL used for the request.

	  scope :admin do
		resources :messages
	  end


		get /admin/messages?a=b

		<%= Rails.application.routes.recognize_path request.url %>	--> {:controller=>"messages", :action=>"index"}
	
	- read header names, values
	
		<% request.headers.each do |k, v| %>
		  <%= k %> : <%= v %><br/>
		<% end %>
	
	- reading params
	
		<%= request.params %>
		{"a"=>"b", "controller"=>"messages", "action"=>"index"}
		
	<%= request.path %>				--> /admin/messages
	<%= params %>					--> {"controller"=>"admin/messages", "action"=>"index"}
	<%= controller_path %>			--> messages
	<%= controller_name %>			--> messages
	<%= controller.class.name %>	--> MessagesController

- response

	body 			This is the string of data being sent back to the client. This is most often HTML.
	status 			The HTTP status code for the response, like 200 for a successful request or 404 for file not found.
	location 		The URL the client is being redirected to, if any.
	content_type 	The content type of the response.
	charset 		The character set being used for the response. Default is "utf-8".
	headers 		Headers used for the response.

	# example

	response.headers["Content-Type"] = "application/pdf"	# use content_type better


- Params
------------------------------------------------------------------------

	# you can read params directly
	params[:some_param]

	# If you're writing a web service application, you might find yourself more comfortable accepting parameters in JSON format. If the "Content-Type" header of your request is set to "application/json", Rails will automatically load your parameters into the params hash, which you can access as you would normally.

	{ "company": { "name": "acme", "address": "123 Carrot Street" } }	--> { name: "acme", address: "123 Carrot Street", company: { name: "acme", address: "123 Carrot Street" } }

	# for example /messages/index?a=b
	
	# param includes
	params.inspect --> #<ActionController::Parameters {"a"=>"b", "controller"=>"messages", "action"=>"index"} permitted: false>
	
	- permitted: false ? yup, don;t use params, instead use item_params
	- all params will be included inside item.
	

	# Rails collects all of the parameters sent along with the request in the params hash
	- query_parameters hash contains parameters that were sent as part of the query string
	- request_parameters hash contains parameters sent as part of the post body
	- path_parameters hash contains parameters that were recognized by the routing as being part of the path leading to this particular controller and action.

		get 'message/:id', to: 'messages#show'


- Strong Params
------------------------------------------------------------------------

	- to encapsulate the permissible parameters
	- When you generate a controller, you will notice the following provate function:
	
	    def person_params
			# default
			params.fetch(:person, {}).permit(:name, :age)
			
			# sometimes
			# params.require(:person).permit(:name, :age)

			# According to documentation, you can't use .require when you don't have an instance of an object.
			# Then .fetch supplies a default params for your uncreated object (#new and #create actions).

		end
	
	- You can permit certain param					-->	params.permit(:id)
	- permit a whole structure of a param			--> params.permit(preferences: {})
	- To permit an entire hash of parameters, the permit! method can be used:	--> params.require(:log_entry).permit!
	- Permit product name and the whole data has	--> params.require(:product).permit(:name, data: {})

	- Nested params
	
		params.permit(:name, { emails: [] },
              friends: [ :name,
                         { family: [ :name ], hobbies: [] }])

	- Using fetch
	
		# using `fetch` you can supply a default and use
		# the Strong Parameters API from there.
		params.fetch(:blog, {}).permit(:title, :author)

	- To permit _destroy (delete)
	
		params.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])
		
	- When using accepts_nested_attributes_for 
	
		# To permit the following data:
		# {"book" => {"title" => "Some Book",
		#             "chapters_attributes" => { "1" => {"title" => "First Chapter"},
		#                                        "2" => {"title" => "Second Chapter"}}}}

		params.require(:book).permit(:title, chapters_attributes: [:title])

- Default_url_options
------------------------------------------------------------------------

	# The ability to set default options whenever you want to generate a url
	# FOr this example

	application_controller.rb:
	
		def default_url_options
			{ locale: I18n.locale }
		end
	
	if you have a route:
	
		scope	:some do
			resources	:messages
		end
	
	then you tried to generate a url
	
		<%= url_for({:controller => 'messages', :a => 'f'}) %>	-> /some/messages?a=f&locale=en



- Filters
------------------------------------------------------------------------

    before_action 	:dome_something		--> runs before the controller action
    after_action	:dome_something 	--> runs after the controller action
    around_action 	:dome_something		--> yields to the controller action wherever it chooses

	before_action	:dome_something, :only => show	#:only, :except
	

	# using skip_
	skip_before_action :authenticate_user! #, only: [:index]


		before_filter do
			@article = Article.find(params[:id]) if params[:id]
		end

	Or

		before_filter :load_article
		# Actions...

		private

		def load_article
			@article = Article.find(params[:id]) if params[:id]
		end

	- around_filter
	
		around_filter :wrap_actions

		def wrap_actions
		  begin
			yield
		  rescue
			render text: "It broke!"
		  end
		end

	- only and except
	
		before_filter :load_article, only: [:show, :edit, :update, :destroy]
		before_filter :load_article, except: [:index, :new, :create]
	
	- Sharing Filters
	
		- Sharing through ApplicationController
		- Generalizing to find_resource
	
			def find_resource
				class_name = params[:controller].singularize
				klass = class_name.camelize.constantize
				self.instance_variable_set "@" + class_name, klass.find(params[:id])
			end

	- Friendly-URl
	
		- Always use paths generated by the router
		
			person_path(@person)
	
		- slug
		
			class Person < ActiveRecord::Base
				def to_param		<-- override
					[id, name.parameterize].join("-")
				end
			end

			# of course you just need to use to_i with params[:id]
			# custom finder
			
			def self.find_by_param(input)
				find_by_name(input)
			end

	- around_action
		
		# run show only within the transaction
		
		class ChangesController < ApplicationController
		  around_action :wrap_in_transaction, only: :show

		  private

		  def wrap_in_transaction
			ActiveRecord::Base.transaction do
			  begin
				yield	<---- here	this also will inlucde the view rendering
			  ensure
				raise ActiveRecord::Rollback
			  end
			end
		  end
		end	
		
		# Also
		
		around_action { |_controller, action| time(&action) }	# & sign is used to pass as block
		def time
			# read time
			yield
			# read time and calculate
		end

		# block example &

		def print_phrase(&block)
			block.call
		end

		# Now we pass there the block with the expression:
		print_phrase { puts "Hello from block!" }



	- another example of how to use filters
	
		class ApplicationController < ActionController::Base

		  before_action do |controller|	<--------- *
			unless controller.send(:logged_in?)
			  flash[:error] = "You must be logged in to access this section"
			  redirect_to new_login_url
			end
		  end

		end
	
	- Also you can use a class
	
		class ApplicationController < ActionController::Base
		  before_action LoginFilter	<---
		end

		class LoginFilter

		  def self.before(controller)
			unless controller.send(:logged_in?)
			  controller.flash[:error] = "You must be logged in to access this section"
			  controller.redirect_to controller.new_login_url
			end
		  end

		end


- Sessions
------------------------------------------------------------------------
- Your application has a session for each user in which you can store small amounts of data that will be persisted between requests.

	> curl -I http://www.google.com | grep Set-Cookie

	Set-Cookie: NID=67=J2xeyegolV0SSneukSOANOCoeuDQs7G1FDAK2j-nVyaoejz-4K6aouUQtyp5B_rK3Z7G-EwTIzDm7XQ3_ZUVNnFmlGfIHMAnZQNd4kM89VLzCsM0fZnr_N8-idASAfBEdS; expires=Wed, 16-Sep-2015 05:44:42 GMT; path=/; domain=.google.com; HttpOnly
	
	- Every time you make a request, your browser will send the cookies back to the server:
	
	Cookie: NID=67=J2xeyegolV0SSneukSOANOCoeuDQs7G1FDAK2j-nVyaoejz-4K6aouUQtyp5B_rK3Z7G-EwTIzDm7XQ3_ZUVNnFmlGfIHMAnZQNd4kM89VLzCsM0fZnr_N8-idASAfBEdS; expires=Wed, 16-Sep-2015 05:44:42 GMT; path=/; domain=.google.com; HttpOnly
	
	- Rails uses Cookies to store session data in secured fashion
	- But, You can only store about 4kb of data in a cookie.
	- Cookies are sent along with every request you make.
	- If you accidentally expose your secret_key_base, your users can change the data you’ve put inside your cookie.
	- Storing the wrong kind of data inside a cookie can be insecure.

- The session is only available in the controller and the view and can use one of several of different storage mechanisms:

    ActionDispatch::Session::CookieStore 		- Stores everything on the client.
    ActionDispatch::Session::CacheStore 		- Stores the data in the Rails cache.
    ActionDispatch::Session::ActiveRecordStore 	- Stores the data in a database using Active Record * (requires the activerecord-session_store gem).
    ActionDispatch::Session::MemCacheStore 		- Stores the data in a memcached cluster (this is a legacy implementation; consider using CacheStore instead).

- If you were keeping track of your sessions with ActiveRecord:

    1- When you call session[:current_user_id] = 1 in your app, and a session doesn’t already exist:
    2- Rails will create a new record in your sessions table with a random session ID (say, 09497d46978bf6f32265fefb5cc52264).
    3- It’ll store {current_user_id: 1} (Base64-encoded) in the data attribute of that record.
    4- And it’ll return the generated session ID, 09497d46978bf6f32265fefb5cc52264, to the browser using Set-Cookie.

	# The next time you request a page,
	
    1- The browser sends that same cookie to your app, using the Cookie: header.
	(like this: Cookie: _my_app_session=09497d46978bf6f32265fefb5cc52264; path=/; HttpOnly)
    2- When you call session[:current_user_id]:
    3- Your app grabs the session ID out of your cookie, and finds its record in the sessions table.
    4- Then, it returns current_user_id out of the data attribute of that record.

- So

	Whether you’re storing sessions in the database, in Memcached, in Redis, or wherever else, they mostly follow this same process. Your cookie only contains a session ID, and your Rails app looks up the data in your session store using that ID.


- Setup

	- session mechanism
	
		Rails.application.config.session_store :active_record_store						--> use database
		Rails.application.config.session_store :cookie_store, key: '_your_app_session'	--> set session key
		Rails.application.config.session_store :cookie_store, key: '_your_app_session', domain: ".example.com"	--> with domain
		
	- Rails sets up (for the CookieStore) a secret key used for signing the session data in config/credentials.yml.enc. 
	- This can be changed with: 
	
		> bin/rails credentials:edit

- Accessing session

	- check current user
	
		@_current_user ||= session[:current_user_id] && User.find_by(id: session[:current_user_id])

	- create the session
	
		if user = User.authenticate(params[:username], params[:password])
		  # Save the user ID in the session so it can be used in
		  # subsequent requests
		  session[:current_user_id] = user.id
		  redirect_to root_url
		end
	
	- destroy
	
		# Remove the user id from the session
		session.delete(:current_user_id)
		
		# Clear the memoized current user
		@_current_user = nil
		redirect_to root_url

- Securing sessions in cookies

	config.force_ssl = true	# in production

	Rails.application.config.action_dispatch.signed_cookie_digest = "SHA256"

	# with rotation
	Rails.application.config.action_dispatch.cookies_rotations.tap do |cookies|
	  cookies.rotate :signed, digest: "SHA1"
	end

	# https://guides.rubyonrails.org/security.html

	
- Flash Messages
------------------------------------------------------------------------
	
	- Before redirects / render

		flash[:notice] = "You have successfully logged out."
		redirect_to root_url
    
	- Within
	
		redirect_to root_url, notice: "You have successfully logged out."
		redirect_to root_url, alert: "You're stuck here!"
		redirect_to root_url, flash: { referral_code: 1234 }
	
	- Showing
	
		<% flash.each do |name, msg| -%>
			<%= content_tag :div, msg, class: name %>
		<% end -%>	

	- You can pass anything that the session can store; you're not limited to notices and alerts:
	
		<% if flash[:just_signed_up] %>
		  <p class="welcome">Welcome to our site!</p>
		<% end %>

	- If you want a flash value to be carried over to another request, use flash.keep:
	
		flash.keep
		redirect_to users_url
		    
	- For example, if the create action fails to save a resource, and you render the new template directly, 
	that's not going to result in a new request, but you may still want to display a message using the flash. 
	To do this, you can use flash.now in the same way you use the normal flash:
	
		flash.now[:error] = "Could not save client"
		render action: "new"



Cookies
------------------------------------------------------------------------

# Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions.

	- basics

		- cookies[:commenter_name] = @comment.author
		- cookies.delete(:commenter_name)
	
	- Rails also provides a signed cookie jar and an encrypted cookie jar for storing sensitive data.
	- These special cookie jars use a serializer to serialize the assigned values into strings and deserializes them into Ruby objects on read.

		Rails.application.config.action_dispatch.cookies_serializer = :json
		
	- Custom
	
		Rails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer

		class CookiesController < ApplicationController
		  def set_cookie
			cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014
			redirect_to action: 'read_cookie'
		  end

		  def read_cookie
			cookies.encrypted[:expiration_date] # => "2014-03-20"
		  end
		end


Middlewares
============================================================================
# https://guides.rubyonrails.org/rails_on_rack.html

> rake middleware

use ActionDispatch::HostAuthorization
use Rack::Sendfile
use ActionDispatch::Static
use ActionDispatch::Executor
use ActionDispatch::ServerTiming
use ActiveSupport::Cache::Strategy::LocalCache::Middleware
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use ActionDispatch::RemoteIp
use Sprockets::Rails::QuietAssets
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use WebConsole::Middleware
use ActionDispatch::DebugExceptions
use ActionDispatch::ActionableExceptions
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::Migration::CheckPending
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ContentSecurityPolicy::Middleware
use ActionDispatch::PermissionsPolicy::Middleware
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
use Rack::TempfileReaper
use Warden::Manager
run Rails7e::Application.routes


middleware/my_middleware.rb

	class MyMiddleware
	  def initialize app
		@app = app
	  end

	  def call env
		# do something...
	  end
	end

- The register this middleware

	module MyRailsApplication
	  class Application < Rails::Application
		*snip*

		# config.middleware.use <class-name>, <first-argument>, <nth-argument>
		config.middleware.use "MyMiddleware"

		*snip*
	  end
	end


There is this tiny caveat when mounting middleware - note that the class name is written as a string, not as a constant. If you mount a middleware class in the config/application.rb file the class name has to be a string. But, if you load the middleware class in the environment files (i.e. config/environment/development.rb) you can mount is as a constant:

- To make files inside lin autoloaded

	# config/initializers/extensions.rb
	Dir["#{Rails.root}/lib/ruby_ext/*.rb"].each { |file| require file }
	Dir["#{Rails.root}/lib/rails_ext/*.rb"].each { |file| require file }

Or

	application.rb:

	config.autoload_paths << "#{Rails.root}/app/middlewares"
	config.eager_load_paths << "#{Rails.root}/app/middlewares"

But

	require_relative '../lib/middleware/my_middleware'



- You can insert yourm iddleware like:

	config.middleware.insert_after ActionDispatch::Executor, Lifo::Cache, page_cache: false


- Or swap:

	# Replace ActionDispatch::ShowExceptions with Lifo::ShowExceptions
	config.middleware.swap ActionDispatch::ShowExceptions, Lifo::ShowExceptions
	
- Or even delete:

	config.middleware.delete Rack::Runtime


- If you want to remove session related middleware, do the following:

	# config/application.rb
	config.middleware.delete ActionDispatch::Cookies
	config.middleware.delete ActionDispatch::Session::CookieStore
	config.middleware.delete ActionDispatch::Flash



Much of Action Controller's functionality is implemented as Middlewares. The following list explains the purpose of each of them:

	Rack::Sendfile

	- Sets server specific X-Sendfile header. Configure this via config.action_dispatch.x_sendfile_header option.


	ActionDispatch::Static

	- Used to serve static files from the public directory. Disabled if config.public_file_server.enabled is false.


Rack (middleware)
------------------------------------------------------------------------

	# Rack is the underlying technology behind nearly all of the web frameworks in the Ruby world. "Rack" is actually a few different things:

	- An architecture - Rack defines a very simple interface, and any code that conforms to this interface can be used in a Rack application. This makes it very easy to build small, focused, and reusable bits of code and then use Rack to compose these bits into a larger application.
	
	- A Ruby gem - Rack is is distributed as a Ruby gem that provides the glue code needed to compose our code.

	# https://thoughtbot.com/upcase/videos/rack

	gem install rack thin
	
	rack1.rb:
	
		require "rack"
		require "thin"

		class Rack1
		  def call(env)

			puts env.inspect

			[ 200, { "Content-Type" => "text/plain" }, ["Hello World"] ]
		  end
		end

		Rack::Handler::Thin.run Rack1.new
	
	--> Using lambda
	
		require "rack"
		require "thin"

		app = -> (env) do
		  [ 200, { "Content-Type" => "text/plain" }, env ]
		end

		Rack::Handler::Thin.run app

- ANother example of Rack

	config.ru:

	class Application
	 def call(env)
		status  = 200
		headers = { "Content-Type" => "text/html" }
		body    = ["This is our small Rack app."]

		[status, headers, body]
	  end
	end

	run Application.new

	> rackup config.ru

Rack rewrite
------------

	config.middleware.insert_before(Rack::Runtime, Rack::Rewrite) do
	 r301 %r{^/(.*)/$}, ‘/$1’
	end


# https://blog.engineyard.com/understanding-rack-apps-and-middleware



Sending & Renders & Redirects & Templates & Layouts & Partials
========================================================================

- Render and Redirects
------------------------------------------------------------------------

- basic

	render action: :edit 	# this will go to edit template inside views/controller folder		--> views/controller_name/view.html.erb
	render :edit 			# same		
	render 'articles/new'	# render new template in views/articles folder (could be for different controller)

	- render a view based on its name along with routes
	get "/home/test", to: "home#test"	--> controller home and method test --> views/home/test.html.erb 
		
	render xml: @article					# will use content type: application/xml
	render json: @article					# will use content type: application/json 
	render js: "alert('Hello Rails');"		# you need to disable forgery protection here, depricated in rails 7


	render html: helpers.tag.strong('Not Found')
	render body: "raw"		# raw content

	- render with status
	render :edit, status: :unprocessable_entity

	render content_type: 'text/plain', layout: false			# render the page .html.erb as text/plain without layout

	render action: :test, layout: true, content_type: 'text/html', :formats => [:text]		# render the page .text.erb using application.text.erb layout as text/plain with content-type html
	
    render :xml => message.to_xml, :status => :created, :location => message_url(message)
	- if you check response location header field --> Location: http://legion.com:3000/messages/1
	- status is :created (201)
	- content type will be automatically set --> Content-Type: application/xml; charset=utf-8
	
- options

    :content_type
    :layout
    :location
    :status
    :formats
    :variants


- variants

	# for example, set variant based on browser type (using gem browser)
	class ApplicationController < ActionController::Base
	  before_action do
		if browser.tablet?
		  request.variant = :tablet
		elsif browser.mobile?
		  request.variant = :phone
		end
	  end
	end

	# in your action method
	respond_to do |format|
      format.html do |html|
        html.phone do	<--------------------------------------
          # Do something specific for phones here.
        end
      end
    end	



- render text

	# this is depricated 
	render text: "Hello, World!"	

	# render plain text	--> use plain: instead iof text:	--> "text/plain" so not to confuse with "text/html"
	render :plain => "hello"
	
	- You can do 
	render plain: "<h1>Hello, World!</h1>", content_type: 'text/plain'
	render plain: "<h1>Hello, World!</h1>", content_type: 'text/html'	--> goes as html

	# By default, if you use the :plain option, the text is rendered without using the current layout. 
	If you want Rails to put the text into the current layout, you need to add the layout: true option and use the .text.erb extension for the layout file.

		application.text.html

	- inline
	render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"
	- xml ?	
	render inline: "xml.p {'Horrid coding practice!'}", type: :builder


- render_to_string
	
	# ActionController::Base.new.render_to_string	# if not used inside controller
	
	html = render_to_string action: :test, layout: false, :formats => [:html]		# render page test, use test.text.erb and return result as string
	html = render_to_string partial: 'home/sendus'

- render a template & pass params to template (same as partial)	

	render :template => "home/test", :locals => {:bo => "hh"}
	
	test.html.erb:
	<%= bo if !local_assigns[:bo].blank? %>

- render rss

	render template: "feed", content_type: "application/rss"


= rendering js:
	
	# All depricated in Rails 7 due to security concerns 
	# you need to disable forgery protection here, 
	
	respond_to do |format|
		format.js { :location => path_to_controller_method_url(argument) }
	end

	respond_to do |format|
		format.js {
		   render :template => "classrooms/create_differently.js.erb", :layout => false
		}
	end	

	respond_to do |format|
		format.js { render :file => "/path/to/save.js.erb" }
	end

	- to call .js file from ajax link
	
	<%= link_to 'Display a name', home_test_path(format: :js), local: false %>



- with layouts

	render :show, layout: 'top_story'
	render :show, layout: false

	# for plain outputs, make sure to have application.text.erb as layout when enabling layout return

	
- Redirect

	redirect_to articles_path
	redirect_to 'http://rubyonrails.org'
	redirect_to 'http://rubyonrails.org', status: 301
	redirect_to articles_path, notice: "Article Created"
	redirect_to login_path, alert: "You must be logged in!"

	redirect_to(@book) 		# redirecto to @book show page 

- redirect_to and render do not return

	redirect_to login_path unless current_user.admin?
	redirect_to articles_path, notice: "Article '#{article.title}' was deleted."
	
# The redirect_to does not stop execution of the method
# so if you have multiple redirects, split them by conditions or use: and return
	
	
- Streaming
	
	# You can render stream if data directly 
	# Remember in controller always
	
	include ActionController::Live
	
	# this will send back a csv file 
	def show
		send_stream(filename: "subscribers.csv") do |stream|
		  stream.write "email_address,updated_at\n"
		  @subscribers.find_each do |subscriber|
			stream.write "#{subscriber.email_address},#{subscriber.updated_at}\n"
		  end
		end
	end
	
	
- Another example

	  def stream
		response.headers['Content-Type'] = 'text/event-stream'
		2.times {
		  response.stream.write "hello world\n"
		  sleep 1
		}
	  ensure
		response.stream.close
	  end	
	
- Sending a file

	# This will read and stream the file 4 kB at the time, avoiding loading the entire file into memory at once. 
	# You can turn off streaming with the :stream option or adjust the block size with the :buffer_size option.
	# If :type is not specified, it will be guessed from the file extension specified in :filename. 
	# If the content-type is not registered for the extension, application/octet-stream will be used.

	render file: "#{Rails.root}/public/404.html", layout: false
	# send_file is often a faster and better option if a layout isn't required.

	send_file("#{Rails.root}/files/clients/#{client.id}.pdf",
				  filename: "#{client.name}.pdf",
				  type: "application/pdf")	


- RESTful Downloads

	# In REST terminology, the PDF file from the example above can be considered just another representation of the client resource.
	
		respond_to do |format|
		  format.html
		  format.pdf { render pdf: generate_pdf(@client) }
		end

	- Add PDF typein config/initializers/mime_types.rb:

		Mime::Type.register "application/pdf", :pdf

	- Then
		
		GET /clients/1.pdf



- Using renderes outside application controller (ActionController::Base)

	# render template
	ApplicationController.render 'templates/name'
	# render action
	FooController.render :index
	# render file
	ApplicationController.render file: 'path'
	# render inline
	ApplicationController.render inline: 'erb content'

	ApplicationController.render(
	  assigns: { foo: 'bar' },
	  inline: 'hello <%= @foo %>'
	) # => 'hello bar'


- request.env

	# All Rails requests have the environment context in which they perform.
	# You can access the environment as request.env in a Rails action
	# A typical web request carries its own environment with it. We usually handle this environment using request.env in controllers. Certain gems like devise depends on env hash for information such as warden token.
	
	
	- renderer defaults: ApplicationController.renderer.defaults
	{:http_host=>"example.org", :https=>false, :method=>"get", :script_name=>"", :input=>""}
	
	{
	  "REQUEST_METHOD" => "GET",
	  "HTTP_HOST"      => "evilmartians.com",
	  "SERVER_PORT"    => "443",
	  "PATH_INFO"      => "/feedback",
	  "QUERY_STRING"   => "source=blog",
	  "HTTPS"          => "on"
	   #...
	}

	request.env['REQUEST_METHOD]	# GET
	request.env['action_dispatch.request.formats]	# text/html

	- you can customize it to 

	renderer = ApplicationController.renderer.new(
	  http_host: 'evilmartians.com',
	  https:      true,
	  method: 'post
	)

	Then use it

	renderer.render inline: '<%= messages_url %>' --> https://evilmartians.com/messages
	renderer.render template: 'show', locals: { order: Order.last }



- Rendering Objects

	# https://medium.com/rubyinside/disassembling-rails-template-rendering-2-a99214c6fde8

	- The default view class ActionView::Base
	- The view class must have the following methods:
		
		- View.new(lookup_context, assigns, controller) — Create a new ActionView instance for a controller and we can also pass the arguments.
		- View#render(option) — Returns String with the rendered template.

    lookup_context = ActionView::LookupContext.new(ActionController::Base.view_paths)
    context = ActionView::Base.with_empty_template_cache.new(lookup_context, {}, nil)    
    renderer = ActionView::Renderer.new(lookup_context)

    @template = renderer.render(context, { file: Rails.root.join('app/views/home/_overview.html.erb'), :formats => :html, :handlers => :erb, :variants => :html})

	- then
	
	<%=  @template.html_safe %>
	
	- how to inject something in the fly
	
	action_view = ActionView::Base.new(ActionController::Base.view_paths, {})
	action_view.class.send(:include, ApplicationHelper)
	action_view.render(file: "example/path", locals: { foo: 1, bar: "hello world" })	# example/path will have access to ApplicationHelper
	
	- example
	
	    @template = ApplicationController.renderer.new(
		  'action_dispatch.request.path_parameters' => {
			controller: 'messages',
			action:     'index'
		  }
		).render inline: '<%= url_for page: 2 %> <%= bar %>', locals: { foo: 1, bar: "hello world" }

		==> /messages?page=2 hello world










- Builder











		
- Layouts
------------------------------------------------------------------------

	- default layout is layouts/application.html.erb
	- specify layout at controller level
	
		  layout "application"

	- specify layout at method level
	
		    render :template => "home/test", :layout => "application"
		    render :template => "home/test", :layout => false

	- content_for

		# app/views/layouts/static_pages.html.erb
		<% content_for :stylesheets do %>
			#navbar {display: none}
		<% end %>
		 
		Then your application.html.erb layout needs to be set up to catch that content and use it, for instance by adding this #yield line:

		# app/views/layouts/application.html.erb
		...
		<head>
			<style><%= yield :stylesheets %></style>
		</head>


- Partials
------------------------------------------------------------------------

	<%= render "shared/menu" %>
	<%= render "shared/menu", {:some => "value} %>				# check in partial local_assigns[:some]
	
	<%= render :partial => "shared/something", :locals => {:bo => "hh"}
	<%= render partial: "link_area", layout: "graybar" %>

	# Within the customer partial, the customer variable will refer to @new_customer from the parent view.
	<%= render partial: "customer", object: @new_customer %>

	# Assuming that the @customer instance variable contains an instance of the Customer model, 
	# this will use _customer.html.erb to render it and will pass the local variable customer 
	# into the partial which will refer to the @customer instance variable in the parent view.
	<%= render @customer %>

	# this will render _product.html.erb (same folder)
	# and wil fetch each product as --> <p>Product Name: <%= product.name %></p>	
	<%= render partial: "product", collection: @products %> --> 
	<%= render partial: "product", collection: @products, as: :item %> --> 

	# also this will render index.html.erb
	<%= render @products %>

	- partials can be rendered inside methods as well when using ajax

	- spacers
	# Rails will render the _product_ruler partial (with no data passed in to it) between each pair of _product partials.
	<%= render partial: @products, spacer_template: "product_ruler" %>

	# using collections with layout
	<%= render partial: "product", collection: @products, layout: "special_layout" %>
	
	# magical partial
	# this
	<%= render partial: 'comments' %>
	# could be written
	<%= render 'comments' %>
	
	# this will iterate throught _article.html.erb partial
	<ul id='articles'><%= render @articles %></ul>



- Rendering Objects

	- The default view class ActionView::Base
	- The view class must have the following methods:
		
		- View.new(lookup_context, assigns, controller) — Create a new ActionView instance for a controller and we can also pass the arguments.
		- View#render(option) — Returns String with the rendered template.

	view = ActionView::Base.new(ActionController::Base.view_paths, {})
	view.assign(schedule: @schedule)
	view.render(file: 'posts/show.html.erb')
	
	
- Builder

	- The Builder gem is a dependency of the rails ActionView component.
	- It provides a simple way to programatically build XML documents and fragments. 
	- Builder design pattern in Ruby
	
		class User
		  attr_accessor :first_name, :last_name
		end

		- initiate
		
		UserBuilder.build do |builder|
			builder.set_name('John', 'Doe')
		end

		class UserBuilder
		  def self.build
			builder = new
			yield(builder)
			builder.user
		  end

		  def initialize
			@user = User.new
		  end

		  def set_name(first_name, last_name)
			@user.first_name = first_name
			@user.last_name = last_name
		  end

		  def user
			@user
		  end
		end

Links
------------------------------------------------------------------------

- example

	<td><%= link_to "Show", book %></td>
	<td><%= link_to "Edit", edit_book_path(book) %></td>
	<td><%= link_to "Destroy", book, data: { turbo_method: :delete, turbo_confirm: "Are you sure?" } %></td>

	<%= link_to some_path(obj) do %>
		some stuf .... 
	<% end %>


	<a href="..." data-turbolinks="false">No turbolinks here</a>.





- Forms, and Request Forgery Protection
------------------------------------------------------------------------
- Generic form

	<%= form_with url: "/search", method: :get do |form| %>
	  <%= form.label :query, "Search for:" %>
	  <%= form.text_field :query %>
	  <%= form.submit "Search" %>
	<% end %>

	<form action="/search" method="get" accept-charset="UTF-8" >
	  <label for="query">Search for:</label>
	  <input id="query" name="query" type="text" />
	  <input name="commit" type="submit" value="Search" data-disable-with="Search" />
	</form>

	- for other controls
	
	<%= form.radio_button :age, "child" %>	>> <input type="radio" id="age_child" name="age" value="child" />
	<%= form.radio_button :age, "adult" %>	>> <input type="radio" id="age_adult" name="age" value="adult" />

	<%= form.check_box :pet_dog %>			>> <input type="checkbox" id="pet_dog" name="pet_dog" value="1" />
	
	- Other helpers
	
	<%= form.text_area :message, size: "70x5" %>				>> <textarea name="message" id="message" cols="70" rows="5"></textarea>		
	<%= form.hidden_field :parent_id, value: "foo" %>			>> <input type="hidden" name="parent_id" id="parent_id" value="foo" />
	<%= form.password_field :password %>						>> <input type="password" name="password" id="password" />
	<%= form.number_field :price, in: 1.0..20.0, step: 0.5 %>	>> <input type="number" name="price" id="price" step="0.5" min="1.0" max="20.0" />
	<%= form.range_field :discount, in: 1..100 %>				>> <input type="range" name="discount" id="discount" min="1" max="100" />
	<%= form.date_field :born_on %>								>> <input type="date" name="born_on" id="born_on" />
	<%= form.time_field :started_at %>							>> <input type="time" name="started_at" id="started_at" />
	<%= form.datetime_local_field :graduation_day %>			>> <input type="datetime-local" name="graduation_day" id="graduation_day" />
	<%= form.month_field :birthday_month %>						>> <input type="month" name="birthday_month" id="birthday_month" />
	<%= form.week_field :birthday_week %>						>> <input type="week" name="birthday_week" id="birthday_week" />
	<%= form.search_field :name %>								>> <input type="search" name="name" id="name" />
	<%= form.email_field :address %>							>> <input type="email" name="address" id="address" />
	<%= form.telephone_field :phone %>							>> <input type="tel" name="phone" id="phone" />
	<%= form.url_field :homepage %>								>> <input type="url" name="homepage" id="homepage" />
	<%= form.color_field :favorite_color %>						>> <input type="color" name="favorite_color" id="favorite_color" value="#000000" />

	- without form
	
	<%= check_box_tag "accept" %>	--> <input type="checkbox" name="accept" id="accept" value="1" />
	


- Bind it to an active model

	@article = Article.find(42)

	<%= form_with model: @article do |form| %>
	  <%= form.text_field :title %>
	  <%= form.text_area :body, size: "60x10" %>
	  <%= form.submit %>
	<% end %>

	# there for all fields names will be formed as : article[field_name]
	<form action="/articles/42" method="post" accept-charset="UTF-8" >
	  <input name="authenticity_token" type="hidden" value="..." />
	  <input type="text" name="article[title]" id="article_title" value="My Title" />
	  <textarea name="article[body]" id="article_body" cols="60" rows="10">
		My Body
	  </textarea>
	  <input type="submit" name="commit" value="Update Article" data-disable-with="Update Article">
	</form>

	- Notice form_with(model: @article) is the same for creating new records, or editing existing one
	
		form_with(model: @article, url: articles_path)								>> in case as new .. auto generated 
		form_with(model: @article, url: article_path(@article), method: "patch")	>> in case of existing one .. auto generated

- fields_for

	# if you had a Person model with an associated ContactDetail model

	<%= form_with model: @person do |person_form| %>
	  <%= person_form.text_field :name %>
	  <%= fields_for :contact_detail, @person.contact_detail do |contact_detail_form| %>
		<%= contact_detail_form.text_field :phone_number %>
	  <% end %>
	<% end %>

	# has many
	
	<%= form_with model: @person do |person_form| %>
	  <%= person_form.text_field :name %>
	  <% @person.addresses.each do |address| %>
		<%= person_form.fields_for address, index: address.id do |address_form| %>
		  <%= address_form.text_field :city %>
		<% end %>
	  <% end %>
	<% end %>
	
	<form accept-charset="UTF-8" action="/people/1" method="post">			
	  <input name="_method" type="hidden" value="patch" />
	  <input id="person_name" name="person[name]" type="text" />
	  <input id="person_address_23_city" name="person[address][23][city]" type="text" />
	  <input id="person_address_45_city" name="person[address][45][city]" type="text" />
	</form>

	--> {'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}

	# notice 
	<%= person_form.fields_for address, index: address.id do |address_form| %>
	is
	<%= fields_for 'person[address][primary]', address, index: address.id do |address_form| %>
	and
	<%= fields_for 'person[address][primary][]', address do |address_form| %>

	model:
	
	class Person < ApplicationRecord
	  has_many :addresses, inverse_of: :person
	  accepts_nested_attributes_for :addresses	--> this will change the params structure **
	end
	class Address < ApplicationRecord
	  belongs_to :person
	end
	
	- when creating new form
	def new
	  @person = Person.new
	  2.times { @person.addresses.build }
	end

	** params structure 

	{
	  'person' => {
		'name' => 'John Doe',
		'addresses_attributes' => {
		  '0' => {
			'kind' => 'Home',
			'street' => '221b Baker Street'
		  },
		  '1' => {
			'kind' => 'Office',
			'street' => '31 Spooner Street'
		  }
		}
	  }
	}

	- therefor controller:
	
	def create
	  @person = Person.new(person_params)
	  # ...
	end

	private
	  def person_params
		params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
	  end

	- remove
		- model
			
			accepts_nested_attributes_for :addresses, allow_destroy: true

			- prevent empty records	
			accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
	
		- form
		
			<li>
				<%= addresses_form.check_box :_destroy %>
				<%= addresses_form.label :kind %>
				<%= addresses_form.text_field :kind %>
				...
			</li>		

		- controller
		
				def person_params
				  params.require(:person).
					permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
				end
		
	
	
- dealing with namespaces

	form_with model: [:admin, @article]			--> admin_article_path(@article)
	form_with model: [:admin, :management, @article]
	
- methods

	form_with(url: search_path, method: "patch")	>> <form accept-charset="UTF-8" action="/search" method="post">
	
	- field method override form method
	
	<%= form_with url: "/posts/1", method: :patch do |form| %>
		<%= form.button "Delete", formmethod: :delete, data: { confirm: "Are you sure?" } %>
		<%= form.button "Update" %>
	<% end %>

- select boxes 

	<%= form.select :city, ["Berlin", "Chicago", "Madrid"] %>	>> <select name="city" id="city"><option value="Berlin">Berlin</option> ... 
	<%= form.select :city, [["Berlin", "BE"], ["Chicago", "CHI"], ["Madrid", "MD"]] %>	[name, value]
	<%= form.select :city, [["Berlin", "BE"], ["Chicago", "CHI"], ["Madrid", "MD"]], selected: "CHI" %>
	
	- Option Groups
	<%= form.select :city,
		  {
			"Europe" => [ ["Berlin", "BE"], ["Madrid", "MD"] ],
			"North America" => [ ["Chicago", "CHI"] ],
		  },
		  selected: "CHI" %>

	- with models
	@person = Person.new(city: "MD")
	<%= form_with model: @person do |form| %>
	  <%= form.select :city, [["Berlin", "BE"], ["Chicago", "CHI"], ["Madrid", "MD"]] %>	>> <select name="person[city]" id="person_city"> ...
	<% end %>

	- Dates / Times
	<%= form.time_zone_select :time_zone %>		--> {"created_at(1i)"=>"2022", "created_at(2i)"=>"2", "created_at(3i)"=>"18"}
	<%= form.date_select :created_at %>			--> {"created_at(1i)"=>"2022", "created_at(2i)"=>"2", "created_at(3i)"=>"18"}
	<%= select_year 1999, prefix: "party" %>	>> <select name="party[year]" id="party_year">	--> "party"=>{"year"=>"1999"}
	
- collections

	<%= form.collection_select :city_id, City.order(:name), :id, :name %>			>> <select name="city_id" id="city_id"> <option value="3">Berlin</option> ...
	<%= form.collection_radio_buttons :city_id, City.order(:name), :id, :name %>	>> <input type="radio" name="city_id" value="3" id="city_id_3">...
	<%= form.collection_check_boxes :city_id, City.order(:name), :id, :name %>		>> <input type="checkbox" name="city_id[]" value="3" id="city_id_3">...

- uploading files

	<%= form_with url: "/uploads", multipart: true do |form| %>		--> multipart must be set 
	  <%= file_field_tag :picture %>
	<% end %>

	and this goes to controller:
	
	def upload
	  uploaded_file = params[:picture]	<---
	  File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file|
		file.write(uploaded_file.read)
	  end
	end

- Other helpers and custoimizations	(ActionView::Helpers::FormBuilder.)

	<%= form_with model: @person do |form| %>
		<%= text_field_with_label form, :first_name %>

	- can be replaced by 
	
	<%= form_with model: @person, builder: LabellingFormBuilder do |form| %>
		<%= form.text_field :first_name %>

	- using class
	
	class LabellingFormBuilder < ActionView::Helpers::FormBuilder
	  def text_field(attribute, options={})
		label(attribute) + super
	  end
	end

- param structure

	<input id="person_name" name="person[name]" type="text" value="Henry"/>							--> {'person' => {'name' => 'Henry'}}
	<input id="person_address_city" name="person[address][city]" type="text" value="New York"/>		--> {'person' => {'address' => {'city' => 'New York'}}}

	<input name="person[phone_number][]" type="text"/> --> params[:person][:phone_number] 			--> "person"=>{"phone_number"=>["", "", ""]}
	<input name="person[phone_number][]" type="text"/>

	<input name="person[addresses][][line1]" type="text"/>	--> "person"=>{"addresses"=>[{"line1"=>"", "line2"=>"", "city"=>""}]}
	<input name="person[addresses][][line2]" type="text"/>
	<input name="person[addresses][][city]" type="text"/>


- remote forms !!

	# check config.action_view.form_with_generates_remote_forms: false
	# :local - By default form submits are remote and unobtrusive XHRs. Disable remote submits with local: true.
	# In Rails 6.0 and 5.2, all forms using form_with implement remote: true by default. These forms will submit data using an XHR (Ajax) request. To disable this include local: true. To dive deeper see Working with JavaScript in Rails guide.



    <%= form_with(
          local: false,
          data: {
            controller: "request",
            request_target: "form",
            request_target_value: "#some_dom_id",
          }) do |form| %>

    <% end %>

	<form 
		data-controller="request" 
		data-request-target="form" 
		data-request-target-value="#some_dom_id" 
		action="/home/show" 
		accept-charset="UTF-8" 
		data-remote="true" 				--> local = false
		method="post">
		<input type="hidden" name="authenticity_token" value="5pb3r03YakCh-920ltp8ICzYOlNPF0Bt9WLdVDjP1z6o9wD4M45GXmvSn5VCdqVN4jsdnT4iCq6_qVdhWrgslQ" autocomplete="off">
	</form>


	<form 
		data-controller="request" 
		data-request-target="form" 
		data-request-target-value="#some_dom_id" 
		 method="post"><input type="hidden" name="authenticity_token" value="V_ykRPEuUQ7dw2pPEXYkCx4xbYORmBN4at7NX9O5ocQZnVMTj3h9EBfqKG7F2v1m0NJKTeCtWbsgFUdqsc5abw" autocomplete="off">
	</form>


- (CSRF) Cross-site request forgery is a type of attack in which a site tricks a user into making requests on another site, possibly adding, modifying, or deleting data on that site without the user's knowledge or permission.

- Example:

	<%= form_with model: @user do |form| %>
	  <%= form.text_field :username %>
	  <%= form.text_field :password %>
	<% end %>

	# will generate
	
	<form accept-charset="UTF-8" action="/users/1" method="post">
		<input type="hidden"											<--- notice this
			   value="67250ab105eb5ad10851c00a5621854a23af5489"
			   name="authenticity_token"/>
		<!-- fields -->
	</form>

	# you can generate this value for mnually crteated forms / ajax
	
		<%= form_authenticity_token %>


- Basic Auth

	class AdminsController < ApplicationController
		http_basic_authenticate_with name: "humbaba", password: "5baa61e4"
	end

- HTTP Digest Authentication

	class AdminsController < ApplicationController
	  USERS = { "lifo" => "world" }

	  before_action :authenticate

	  private
		def authenticate
		  authenticate_or_request_with_http_digest do |username|
			USERS[username]
		  end
		end
	end

- HTTP Token Authentication

	class PostsController < ApplicationController
	  TOKEN = "secret"

	  before_action :authenticate

	  private
		def authenticate
		  authenticate_or_request_with_http_token do |token, options|
			ActiveSupport::SecurityUtils.secure_compare(token, TOKEN)
		  end
		end
	end

- Filter out sensitive data from logs

	# check file: config/initializers/filter_parameter_logging.rb
	
	Or set inside environment file
	
		config.filter_parameters << :password
	
	
- Rescue

	- rescue_from
	
		application_controller.rb:
		
		class ApplicationController < ActionController::Base

		  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
		  # rescue_from User::NotAuthorized, with: :user_not_authorized

		  private
			def record_not_found
			  render plain: "404 Not Found", status: 404
			  # Or
			  # flash[:error] = "You don't have access to this section."
			  # redirect_back(fallback_location: root_path)
			end
		end
	
	- And from your controller
	
		  before_action :check_authorization
		  
		  private
		  
			# If the user is not authorized, just throw the exception.
			def check_authorization
			  raise User::NotAuthorized unless current_user.admin?
			end

- Error messages


	  <div>
		<%= form.label :title %><br>
		<%= form.text_field :title %>
		<% @article.errors.full_messages_for(:title).each do |message| %>
		  <div><%= message %></div>
		<% end %>
	  </div>






- Helpers
------------------------------------------------------------------------


- Ready made helpers

	time_ago_in_words(Time.now)
	# "less than a minute"
	time_ago_in_words(Time.now + 60)
	# "1 minute"
	time_ago_in_words(Time.now + 600)
	# "10 minutes"

	number_to_human(10_000)
	# "10 Thousand"

- How

	# app/helpers/user_helper.rb
	module UserHelper
	  def format_name(user)
		if user.gender == "M"
		  "Mr. #{user.name}"
		else
		  "Ms. #{user.name}"
		end
	  end
	end


	This helper will be autoloaded when dealing with users controller & views

	<%= format_name(@user) %>
	
- Using helpers from controller

	class UsersController
	  def index
		helpers.time_ago_in_words(Time.now)
	  end
	end

- Note

	- don;t relay on @objects, but pass parameters
	


- Presenter
------------------------------------------------------------------------


	# app/presenters/post_presenter.rb
	class PostPresenter
	  def initialize(post)
		@post = post
	  end
	  def title_without_forbidden_words
		@post.title.gsub("forbidden word", "")
	  end
	  def css_color
		@post.draft? ? "orange" : "green"
	  end
	end

	- in your view
	
	<% presenter = PostPresenter.new(post) %>
	<p>
	  Post title: <%= presenter.title_without_forbidden_words %>
	  <%= link_to "Read post", post, class: "w-75 p-3 text-#{presenter.css_color} border-#{presenter.css_color}" %>
	</p>






Ajax & ejs	(for Rails7, check actioncable & turbo)
------------------------------------------------------------------------

There are several ways to use ajax with rails applications.
- the hard way, using jQuery directly .. or any other libraries 
- the rails way .. 

	Rails.ajax({
		url: '/url',
		type: 'get',
		data: '',
		success: function(data) {},
		error: function(data) {},
	})

	Or (recommended)
		
- rails-ujs	# not used for rails 7

# Hotwire’s combination of Turbo and Stimulus deliver all the tools needed to produce fantastic user experiences that leave little to nothing on the table in contrast to single-page applications – at a fraction of the complexity. 

# It’s the default choice for new Rails apps, replacing the far more limited options of Turbolinks and Rails UJS.




Render status types
--------------------

Response Class 	HTTP Status Code 	Symbol
Informational 	100 	:continue
	101 	:switching_protocols
	102 	:processing
Success 	200 	:ok
	201 	:created
	202 	:accepted
	203 	:non_authoritative_information
	204 	:no_content
	205 	:reset_content
	206 	:partial_content
	207 	:multi_status
	208 	:already_reported
	226 	:im_used
Redirection 	300 	:multiple_choices
	301 	:moved_permanently
	302 	:found
	303 	:see_other
	304 	:not_modified
	305 	:use_proxy
	307 	:temporary_redirect
	308 	:permanent_redirect
Client Error 	400 	:bad_request
	401 	:unauthorized
	402 	:payment_required
	403 	:forbidden
	404 	:not_found
	405 	:method_not_allowed
	406 	:not_acceptable
	407 	:proxy_authentication_required
	408 	:request_timeout
	409 	:conflict
	410 	:gone
	411 	:length_required
	412 	:precondition_failed
	413 	:payload_too_large
	414 	:uri_too_long
	415 	:unsupported_media_type
	416 	:range_not_satisfiable
	417 	:expectation_failed
	421 	:misdirected_request
	422 	:unprocessable_entity
	423 	:locked
	424 	:failed_dependency
	426 	:upgrade_required
	428 	:precondition_required
	429 	:too_many_requests
	431 	:request_header_fields_too_large
	451 	:unavailable_for_legal_reasons
Server Error 	500 	:internal_server_error
	501 	:not_implemented
	502 	:bad_gateway
	503 	:service_unavailable
	504 	:gateway_timeout
	505 	:http_version_not_supported
	506 	:variant_also_negotiates
	507 	:insufficient_storage
	508 	:loop_detected
	510 	:not_extended
	511 	:network_authentication_required


















