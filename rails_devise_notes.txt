Devise
==========================================================================================
gem 'devise'

> bundle install
> rails generate devise:install

      create  config/initializers/devise.rb
      create  config/locales/devise.en.yml

Depending on your application's configuration some manual setup may be required:

  1. Ensure you have defined default url options in your environments files. Here
     is an example of default_url_options appropriate for a development environment

     in config/environments/development.rb:

       	config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }


     In production, :host should be set to the actual host of your application.

     * Required for all applications. *

  2. Ensure you have defined root_url to *something* in your config/routes.rb.
     For example:

       root to: "home#index"
     
     * Not required for API-only Applications *

  3. Ensure you have flash messages in app/views/layouts/application.html.erb.
     For example:

       <p class="notice"><%= notice %></p>
       <p class="alert"><%= alert %></p>

     * Not required for API-only Applications *

  4. You can copy Devise views (for customization) to your app by running:

       rails g devise:views
       
     * Not required *


  5. and COntrollers
  
         rails generate devise:controllers users

	if you done, set the controllers in routes as following:
	# https://github.com/heartcombo/devise#configuring-controllers
	
		devise_for :users, controllers: { sessions: 'users/sessions' }


config/environments/development.rb:

	config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }
	config.action_mailer.delivery_method = :smtp
  	config.action_mailer.smtp_settings = { :address => "localhost", :port => 1025 }

> rails generate devise User
> rails db:migrate


User model (models/user.rb) generated by devise
------------------------------------------------

The Devise method in your models also accepts some options to configure its modules. 
For example, you can choose the cost of the hashing algorithm with:

devise :database_authenticatable, :registerable, :confirmable, :recoverable, stretches: 13

	- Database Authenticatable: hashes and stores a password in the database to validate the authenticity of a user while signing in. The authentication can be done both through POST requests or HTTP Basic Authentication.
	- Omniauthable: adds OmniAuth (https://github.com/omniauth/omniauth) support.
	- Confirmable: sends emails with confirmation instructions and verifies whether an account is already confirmed during sign in.
	- Recoverable: resets the user password and sends reset instructions.
	- Registerable: handles signing up users through a registration process, also allowing them to edit and destroy their account.
	- Rememberable: manages generating and clearing a token for remembering the user from a saved cookie.
	- Trackable: tracks sign in count, timestamps and IP address.
	- Timeoutable: expires sessions that have not been active in a specified period of time.
	- Validatable: provides validations of email and password. It's optional and can be customized, so you're able to define your own validations.
	- Lockable: locks an account after a specified number of failed sign-in attempts. Can unlock via email or after a specified time period.


	- Besides :stretches, you can define :pepper, :encryptor, :confirm_within, :remember_for, :timeout_in, :unlock_in among other options. 
	- For more details, see the initializer file that was created when you invoked the "devise:install" generator described above. This file is usually located at 
		/config/initializers/devise.rb.

# More details: --> https://github.com/heartcombo/devise/wiki/Extensions

make sure to double check the devise migration to enable the features you need such as: confirmable


- based on generated migration fo User table, uncomment the feature you want to have in User model:

	class DeviseCreateUsers < ActiveRecord::Migration[7.0]
	  def change
		create_table :users do |t|
		  ## Database authenticatable
		  t.string :email,              null: false, default: ""
		  t.string :encrypted_password, null: false, default: ""

		  ## Recoverable
		  t.string   :reset_password_token
		  t.datetime :reset_password_sent_at

		  ## Rememberable
		  t.datetime :remember_created_at

		  ## Trackable
		  # t.integer  :sign_in_count, default: 0, null: false
		  # t.datetime :current_sign_in_at
		  # t.datetime :last_sign_in_at
		  # t.string   :current_sign_in_ip
		  # t.string   :last_sign_in_ip

		  ## Confirmable
		  # t.string   :confirmation_token
		  # t.datetime :confirmed_at
		  # t.datetime :confirmation_sent_at
		  # t.string   :unconfirmed_email # Only if using reconfirmable

		  ## Lockable
		  # t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
		  # t.string   :unlock_token # Only if unlock strategy is :email or :both
		  # t.datetime :locked_at


		  t.timestamps null: false
		end

		add_index :users, :email,                unique: true
		add_index :users, :reset_password_token, unique: true
		# add_index :users, :confirmation_token,   unique: true
		# add_index :users, :unlock_token,         unique: true
	  end
	end

if you want to add confirmable feature .. 
--------------------------------------------
> rails g migration add_extra_to_users

class ExtraDevise < ActiveRecord::Migration[6.0]
  def change
    change_table(:users) do |t|

	# Use t. syntax better
      add_column :users, :confirmation_token, :string
      add_column :users, :confirmed_at, :datetime
      add_column :users, :confirmation_sent_at, :datetime
      add_column :users, :unconfirmed_email, :string # Only if using reconfirmable
      add_index :users, :confirmation_token, unique: true

    end
  end
end


user.rb
--------
devise :database_authenticatable, 
         :recoverable, :rememberable, :validatable, :rememberable, :registerable <--- ,:confirmable


class DeviseTokenAuthCreateUsers < ActiveRecord::Migration[7.0]
  def change

    change_table(:users) do |t|

	  # Example ..........
      ## Trackable
      t.integer  :sign_in_count, default: 0, null: false
      t.datetime :current_sign_in_at
      t.datetime :last_sign_in_at
      t.inet     :current_sign_in_ip
      t.inet     :last_sign_in_ip

	end
  end
end


Controller filters and helpers:
--------------------------------
Devise will create some helpers to use inside your controllers and views. To set up a controller with user authentication, just add this before_action (assuming your devise model is 'User'):

	before_action :authenticate_user!

To verify if a user is signed in, use the following helper:

	user_signed_in?

For the current signed-in user, this helper is available:

	current_user

You can access the session for this scope:

	user_session

routes:

	root to: 'home#index'
	
! > rake db:sessions:clear


For links

- create menu folder in devise folder
- add the following partials

_login_items.html.erb:

	<% if user_signed_in? %>
		<li class="nav-item">
		  <%#= link_to('Logout', main_app.destroy_user_session_path, method: :delete) %>
		  <%= link_to "Logout", main_app.destroy_user_session_path, :method => :delete, :data => {"turbo-method": :delete,  :no_turbolink => true } %>

		</li>
	<% else %>
		<li class="nav-item">
		  <%= link_to('Login', main_app.new_user_session_path) %>
		</li>
	<% end %>

_registration_items.html.erb:


	<% if user_signed_in? %>
		<li class="nav-item">
		  <%= link_to('Edit registration', main_app.edit_user_registration_path) %>
		</li>
	<% else %>
		<li class="nav-item">
		  <%= link_to('Register', main_app.new_user_registration_path) %>
		</li>
	<% end %>

  <%= render "devise/menu/login_items" %>
  <%= render "devise/menu/registration_items" %>






add first_name, last_name, username, address_id
------------------------------------------------

- To add new field, add a migration first:

	$ rails generate migration add_name_to_users name:string surname:string

	class AddNameToUsers < ActiveRecord::Migration[6.0]
	  def change
		add_column :users, :name, :string
		add_column :users, :surname, :string
	  end
	end

	> rails db:migrate

- then update the new / edit forms


	  <div class="field">
		<%= f.label :name %><br />
		<%= f.text_field :name %>
	  </div>

	  <div class="field">
		<%= f.label :surname %><br />
		<%= f.text_field :surname %>
	  </div>


* Important
- application.rb

	class ApplicationController < ActionController::Base
	  protect_from_forgery with: :exception

	  before_action :update_allowed_parameters, if: :devise_controller?

	  protected

	  def update_allowed_parameters
		devise_parameter_sanitizer.permit(:sign_up) { |u| u.permit(:name, :surname, :email, :password)}
		devise_parameter_sanitizer.permit(:account_update) { |u| u.permit(:name, :surname, :email, :password, :current_password)}
	  end
	end




Configuring devise views
------------------------

> rails generate devise:views users # views
> rails generate devise:controllers users # controllers

routes.rb:

  devise_for :users, controllers: {
    sessions: 'users/sessions',
    confirmations: 'users/confirmations',
    registrations: 'users/registrations',
    passwords: 'users/passwords',
    unlocks: 'users/unlocks',
    mailer: 'users/mailer',
  }


db/seeds.rb
------------
	if !User.find_by_email("admin@rapidfire.com")
	  user = User.create(
		:email                 => "admin@rapidfire.com",
		:role                   => 0,
		:password              => "admin123",
		:password_confirmation => "admin123",
#		:confirmed_at => DateTime.now

	  )
	  user.save!
	end


	if !User.find_by_email("test@rapidfire.com")
	  user = User.create(
		:email                 => "test@rapidfire.com",
		:role                   => 1,
		:password              => "test123",
		:password_confirmation => "test123",
# 		:confirmed_at => DateTime.now

	  )
	  user.save!
	end
	
> rake db:seed


add roles:
----------

user.rb

	enum role:  {admin: 0, user: 1}

> rails g migration add_roles_to_users


	class AddRoleToUsers < ActiveRecord::Migration[6.0]
	  def change
		add_column :users, :role, :integer
	  end
	end

	# get back to seeds.rb to add the :confirmed_at => DateTime.now


To check the role .. 

	<%= current_user.user? %>
	<%= current_user.admin? %>

Add helper functions : :authenticate_admin_user

application_controller.rb:

	private

	def after_sign_in_path_for(resource_or_scope)
		if current_user && !current_user.admin?
		  "/"
		else
		  "/"
		end
	end

	# to be used by survey (rapidfire)
	def can_administer?
		current_user.try(:admin?)
	end


	/ ---------------------------------------------------------------------------------- /

	# to be used by active admin
	def authenticate_admin_user!

	authenticate_admin_user!
	    authenticate_user!
		unless current_user.admin?
		  flash[:alert] = "This area is restricted to administrators only."
		  redirect_to root_path
		end
	end

	def current_admin_user
		return nil if user_signed_in? && !current_user.admin?
		current_user
	end


	# In Rails 4.2 and above
	def verified_request?
		super || valid_authenticity_token?(session, request.headers['X-XSRF-TOKEN'])
	end

	/ ---------------------------------------------------------------------------------- /


Now, how to check if is admin, for example, in active admin it requires the following function:
----------- check active_admin.rb

	# notice all functions must map to existing devise ones

  config.authentication_method = :authenticate_user!


  config.current_user_method = :current_user
  config.logout_link_path = :destroy_user_session_path
  config.logout_link_method = :delete


- More about Roles
-------------------

# https://learn.co/lessons/devise_roles_readme#:~:text=Roles%20are%20a%20way%20to,you%20are%20authorized%20to%20do.










devise OmniAuth:
----------------

	config.omniauth :github, 'APP_ID', 'APP_SECRET', scope: 'user,public_repo'
	https://github.com/heartcombo/devise/wiki/OmniAuth:-Overview


devise Strong Parameters :
-------------------------






Rails 6, Devise 4.7 +
-------------------------------------------------------------------------
	https://wajeeh-ahsan.medium.com/rails-user-authentication-with-devise-and-simple-token-authentication-7beafd1bb863
	https://github.com/gonzalo-bulnes/simple_token_authentication#make-models-token-authenticatable

	gem "simple_token_authentication"

		> bundle install

	Add auth. token:
		
		> rails g migration add_authentication_token_to_users "authentication_token:string{30}:uniq"
		> rake db:migrate
	
	user.rb:
	
		class User < ActiveRecord::Base
		  acts_as_token_authenticatable
		end


	# config/initializers/simple_token_authentication.rb
	
		SimpleTokenAuthentication.configure do |config|

		  # Configure the session persistence policy after a successful sign in,
		  # in other words, if the authentication token acts as a signin token.
		  # If true, user is stored in the session and the authentication token and
		  # email may be provided only once.
		  # If false, users must provide their authentication token and email at every request.
		  # config.sign_in_token = false

		  # Configure the name of the HTTP headers watched for authentication.
		  #
		  # Default header names for a given token authenticatable entity follow the pattern:
		  #   { entity: { authentication_token: 'X-Entity-Token', email: 'X-Entity-Email'} }
		  #
		  # When several token authenticatable models are defined, custom header names
		  # can be specified for none, any, or all of them.
		  #
		  # Note: when using the identifiers options, this option behaviour is modified.
		  # Please see the example below.
		  #
		  # Examples
		  #
		  #   Given User and SuperAdmin are token authenticatable,
		  #   When the following configuration is used:
		  #     `config.header_names = { super_admin: { authentication_token: 'X-Admin-Auth-Token' } }`
		  #   Then the token authentification handler for User watches the following headers:
		  #     `X-User-Token, X-User-Email`
		  #   And the token authentification handler for SuperAdmin watches the following headers:
		  #     `X-Admin-Auth-Token, X-SuperAdmin-Email`
		  #
		  #   When the identifiers option is set:
		  #     `config.identifiers = { super_admin: :phone_number }`
		  #   Then both the header names identifier key and default value are modified accordingly:
		  #     `config.header_names = { super_admin: { phone_number: 'X-SuperAdmin-PhoneNumber' } }`
		  #
		  # config.header_names = { user: { authentication_token: 'X-User-Token', email: 'X-User-Email' } }

		  # Configure the name of the attribute used to identify the user for authentication.
		  # That attribute must exist in your model.
		  #
		  # The default identifiers follow the pattern:
		  # { entity: 'email' }
		  #
		  # Note: the identifer must match your Devise configuration,
		  # see https://github.com/plataformatec/devise/wiki/How-To:-Allow-users-to-sign-in-using-their-username-or-email-address#tell-devise-to-use-username-in-the-authentication_keys
		  #
		  # Note: setting this option does modify the header_names behaviour,
		  # see the header_names section above.
		  #
		  # Example:
		  #
		  #   `config.identifiers = { super_admin: 'phone_number', user: 'uuid' }`
		  #
		  # config.identifiers = { user: 'email' }

		  # Configure the Devise trackable strategy integration.
		  #
		  # If true, tracking is disabled for token authentication: signing in through
		  # token authentication won't modify the Devise trackable statistics.
		  #
		  # If false, given Devise trackable is configured for the relevant model,
		  # then signing in through token authentication will be tracked as any other sign in.
		  #
		  # config.skip_devise_trackable = true
		end		



	application_controller.rb:
	
		class ApplicationController < ActionController::API # ActionController::Base, ActionController::Metal ... etc
			
			acts_as_token_authentication_handler_for User
			
			  # Security note: controllers with no-CSRF protection must disable the Devise fallback,
			  # see #49 for details.
			  # acts_as_token_authentication_handler_for User, fallback: :none

			  # The token authentication requirement can target specific controller actions:
			  # acts_as_token_authentication_handler_for User, only: [:create, :update, :destroy]
			  # acts_as_token_authentication_handler_for User, except: [:index, :show]
			  #
			  # Or target specific controller conditions:
			  # acts_as_token_authentication_handler_for User, unless: lambda { |controller| controller.request.format.html? }
			  # acts_as_token_authentication_handler_for User, if: lambda { |controller| controller.request.format.json? }

			  # Several token authenticatable models can be handled by the same controller.
			  # If so, for all of them except the last, the fallback should be set to :none.
			  #
			  # Please do notice that the order of declaration defines the order of precedence.
			  #
			  # acts_as_token_authentication_handler_for Admin, fallback: :none
			  # acts_as_token_authentication_handler_for SpecialUser, fallback: :none
			  # acts_as_token_authentication_handler_for User # the last fallback is up to you

			  # Aliases can be defined for namespaced models:
			  #
			  # acts_as_token_authentication_handler_for Customer::Representative, as: :facilitator
			  # acts_as_token_authentication_handler_for SpecialUser, as: :user
			  #
			  # When defined, aliases are used to define both the params and the header names to watch.
			  # E.g. facilitator_token, X-Facilitator-Token			
			
			
			
		end

	Route for API:
	
		Rails.application.routes.draw do
		  devise_for :users
		  
		  namespace :api, defaults: {format: :json} do
			namespace :v1 do 
			  devise_scope :user do
				post "sign_up", to: "registrations#create"
				post "sign_in", to: "sessions#create"
			  end
			end
		  end
		end

	app/controllers/api/v1/registrations_controller.rb
	
		class Api::V1::RegistrationsController < Devise::RegistrationsController
			before_action :ensure_params_exist, only: :create
			skip_before_filter :verify_authenticity_token, :only => :create
			# sign up
			def create
			  user = User.new user_params
			  if user.save
				render json: {
				  messages: "Sign Up Successfully",
				  is_success: true,
				  data: {user: user}
				}, status: :ok
			  else
				render json: {
				  messages: "Sign Up Failded",
				  is_success: false,
				  data: {}
				}, status: :unprocessable_entity
			  end
			end
		  
			private
			def user_params
			  params.require(:user).permit(:email, :password, :password_confirmation)
			end
		  
			def ensure_params_exist
			  return if params[:user].present?
			  render json: {
				  messages: "Missing Params",
				  is_success: false,
				  data: {}
				}, status: :bad_request
			end
		end

	app/controller/v1/sessions_controller.rb:
	
		class Api::V1::SessionsController < Devise::SessionsController
		  before_action :sign_in_params, only: :create
		  before_action :load_user, only: :create
		  # sign in
		  def create
			if @user.valid_password?(sign_in_params[:password])
			  sign_in "user", @user
			  render json: {
				messages: "Signed In Successfully",
				is_success: true,
				data: {user: @user}
			  }, status: :ok
			else
			  render json: {
				messages: "Signed In Failed - Unauthorized",
				is_success: false,
				data: {}
			  }, status: :unauthorized
			end
		  end

		  private
		  def sign_in_params
			params.require(:sign_in).permit :email, :password
		  end

		  def load_user
			@user = User.find_for_database_authentication(email: sign_in_params[:email])
			if @user
			  return @user
			else
			  render json: {
				messages: "Cannot get User",
				is_success: false,
				data: {}
			  }, status: :failure --> 404
			end
		  end
		end
	
	To signup
	
		send to /api/v1/signup a post request
		
		{
			"user": {
				"email": "ibrahimsalem75@gmail.com",
				"password": "123456",
				"password_confirmation": "123456"
			}
		}
		
		-->
		
		{
			"messages": "Sign Up Successfully",
			"is_success": true,
			"data": {
				"user": {
					"id": 8,
					"email": "abc@example.com",
					"created_at": "2021-05-06T16:16:21.762Z",
					"updated_at": "2021-05-06T16:16:21.762Z",
					"role": null,
					"authentication_token": "1RDJyX3AKyLPpyHDxPBv"	<----------- notice this
				}
			}
		}
				
		

	To Sign in
	
		send post request to /api/v1/sign_in
		
		{
		 "user": {
		  "email":"test@rapidfire.com",
		  "password":"test123"
		 }
		}
		
	response could be:

	{
		"messages": "Cannot get User",
		"is_success": false,
		"data": {}
	}

	or

	{
		"error": "You have to confirm your email address before continuing."
	}
	
	or
	
	{
		"messages": "Signed In Successfully",
		"is_success": true,
		"data": {
			"user": {
				"id": 8,
				"email": "abc@example.com",
				"created_at": "2021-05-06T16:16:21.762Z",
				"updated_at": "2021-05-06T16:16:21.762Z",
				"role": null,
				"authentication_token": "1RDJyX3AKyLPpyHDxPBv"	<----------- token
			}
		}
	}
	
	Use the following methods to send and interact with server using the authentication token:
	
	Authentication Method 1: Query Params:

		You can authenticate passing the user_email and user_token params as query params:

		GET https://secure.example.com?user_email=alice@example.com&user_token=1G8_s7P-V-4MGojaKD7a
		The token authentication handler (e.g. ApplicationController) will perform the user sign in if both are correct.

	Authentication Method 2: Request Headers:

		You can also use request headers (which may be simpler when authenticating against an API):

		X-User-Email alice@example.com
		X-User-Token 1G8_s7P-V-4MGojaKD7a

	


How to use JSON with Devise directly
-------------------------------------

- create a user :)

You should disable CSRF protection and enable JSON response type:

class RegistrationsController < Devise::RegistrationsController

  skip_before_action :verify_authenticity_token

  respond_to :json

end  
then just call POST request with parameters and format suffix (.json)

curl -X POST \
  --form "user[email]=user111@example.com" \
  --form "user[password]=password" \
  --form "user[password_confirmation]=password" \
  'http://localhost:3000/users.json'
  
  
Now, you see the CSRF protection thingy, 
-----------------------------------------





Using devise-token_auth 
------------------------

***************** Old ********************
# https://github.com/baschtl/devise-token_authenticatable

	devise-token_authenticatable	devise
	~> 0.1							~> 3.2.0
	~> 0.2							~> 3.3.0
	~> 0.3							~> 3.4.0
	~> 0.4.0, < 0.4.9				~> 3.5.0, < 3.5.2
	~> 0.4.9						~> 3.5.2
	~> 0.5.x, <= 1.0.2				>= 4.0.0, < 4.6.0
	~> 1.1.0						>= 4.0.0, < 5.0.0

- # install the gem 
- migration:

	>  rails g migration add_auth_to_devise

	def change
		add_column :users, :authentication_token, :text
		add_column :users, :authentication_token_created_at, :datetime

		add_index :users, :authentication_token, unique: true
	end

Add :token_authenticatable to your devise model:

	class User < ActiveRecord::Base
	  devise :database_authenticatable, :token_authenticatable
	end

******************** Use this one **************************************

# https://github.com/lynndylanhurley/devise_token_auth
# https://medium.com/@tunbosunogunlana1/authentication-api-with-rails-6-0-and-device-token-auth-gem-39ca1ad0520e
# https://devise-token-auth.gitbook.io/devise-token-auth/

# https://devise-token-auth.gitbook.io/devise-token-auth/usage
# 


gem 'devise_token_auth', git: "https://github.com/lynndylanhurley/devise_token_auth"

- For existing rails + devise follow this
# https://whatraghulearned.wordpress.com/2019/07/15/add-devise_token_auth-to-an-existing-rails-app/	
# https://github.com/cyu/rack-cors

- Gems

	gem "devise", "~> 4.8"
	gem 'devise_token_auth', git: "https://github.com/lynndylanhurley/devise_token_auth"
	gem 'omniauth'
	gem 'rack-cors'		
	
- Config

	> rails g devise_token_auth:install [USER_CLASS] [MOUNT_PATH]
	> rails g devise_token_auth:install_mongoid [USER_CLASS] [MOUNT_PATH]

	> rails g devise_token_auth:install User auth


      create  config/initializers/devise_token_auth.rb
      insert  app/controllers/application_controller.rb
      gsub  config/routes.rb
      create  db/migrate/20220202181935_devise_token_auth_create_users.rb
      insert  app/models/user.rb

- create a new base API and move from Application to the new API controller

	> rails g controller api/v1/Posts

		include DeviseTokenAuth::Concerns::SetUserByToken
	
	as:
	
	class Api::V1::PostsController < JSONAPI::ResourceController #< ApplicationController
	
	  include DeviseTokenAuth::Concerns::SetUserByToken
	  def configure_permitted_parameters
		devise_parameter_sanitizer.permit(:sign_in, keys: [:email, :password])
	  end
	end
	
- update the route:

  # has been removed since we are adding devise token auth to existing devise
  # mount_devise_token_auth_for 'User', at: 'auth'
  # instead ..
  namespace :api, defaults: { format: 'json' } do
    namespace :v1 do
      mount_devise_token_auth_for 'User', at: 'auth'

      get 'test/results'
      # resources :test, only: [:results]
    end
  end

- update the migration from 20220202181935_devise_token_auth_create_users.rb to 20220202181935_devise_token_auth_update_users.rb
- and remove all existing fields .. 

	class DeviseTokenAuthUpdateUsers < ActiveRecord::Migration[7.0]
	  def change

		change_table(:users) do |t|		<----------- instead of create_table
		  ## Required
		  t.string :provider, :null => false, :default => "email"
		  t.string :uid, :null => false, :default => ""

		  ## Database authenticatable
		  # t.string :encrypted_password, :null => false, :default => ""

		  ## Recoverable
		  # t.string   :reset_password_token
		  # t.datetime :reset_password_sent_at
		  t.boolean  :allow_password_change, :default => false

		  ## Rememberable
		  # t.datetime :remember_created_at

		  ## Confirmable
		  t.string   :confirmation_token
		  t.datetime :confirmed_at
		  t.datetime :confirmation_sent_at
		  t.string   :unconfirmed_email # Only if using reconfirmable

		  ## Lockable
		  # t.integer  :failed_attempts, :default => 0, :null => false # Only if lock strategy is :failed_attempts
		  # t.string   :unlock_token # Only if unlock strategy is :email or :both
		  # t.datetime :locked_at

		  ## User Info
		  t.string :name
		  t.string :nickname
		  t.string :image
		  # t.string :email

		  ## Tokens
		  t.json :tokens


		  ## Trackable		<------------- added
		  t.integer  :sign_in_count, default: 0, null: false
		  t.datetime :current_sign_in_at
		  t.datetime :last_sign_in_at
		  t.inet     :current_sign_in_ip
		  t.inet     :last_sign_in_ip

		  # t.timestamps
		end

		# add_index :users, :email,                unique: true
		add_index :users, [:uid, :provider],     unique: true
		# add_index :users, :reset_password_token, unique: true
		add_index :users, :confirmation_token,   unique: true
		# add_index :users, :unlock_token,         unique: true
	  end
	end

- User.rb: Remove the modules you already included. I don’t need omniauth at this moment so i removed it.

	devise :database_authenticatable, :registerable,
          :recoverable, :rememberable, :trackable, :validatable,
          :confirmable, :omniauthable

	include DeviseTokenAuth::Concerns::User

- init../cors.rb

	Rails.application.config.middleware.insert_before 0, Rack::Cors do
	  allow do
		origins '*'
		#    resource '*', headers: :any, methods: [:get, :post, :patch, :put]
		resource '*', headers: :any,
				 expose: %w(etag access-token uid expiry token-type client Rate-Search-Uuid),
				 methods: [:get, :post, :delete, :put, :patch, :options, :head]
	  end
	end

	
- application controller:

	  
	  # protect_from_forgery with: :exception
	  # protect_from_forgery with: :null_session, if: -> { request.format.json? }
	  # protect_from_forgery with: :null_session

	  protect_from_forgery with: :exception, if: :verify_api

	  
	  before_action :authenticate_user!, if: :verify_api #, except: [:home]
	  wrap_parameters false

	  def verify_api
		params[:controller].split('/')[0] != 'devise_token_auth'
	  end

- devise_token_auth.rb:

	config.enable_standard_devise_support = true



curl -X POST -v -H 'Content-Type: application/json' http://legion.com:3000/api/v1/auth/sign_in -d '{"email": "test@test.com", "password": "test123" }'

-> {"data":{"email":"test@test.com","provider":"email","uid":"test@test.com","id":1,"allow_password_change":false,"name":null,"nickname":null,"image":null}}
-> header

< access-token: QnbgbYoIdrM9z-D54Zr8Dw
< token-type: Bearer
< client: 0jO_A-hDgA5mMAGIGhY3ng
< expiry: 1645100202
< uid: test@test.com

To use this with API
* remember, we put the API controllers


class Api::V1::BaseController < ActionController::API #< JSONAPI::ResourceController #< ApplicationController

  include DeviseTokenAuth::Concerns::SetUserByToken
  respond_to :json

  # before_action :configure_permitted_parameters, if: :devise_controller?
  before_action :authenticate_user!

  # def configure_permitted_parameters
  #   devise_parameter_sanitizer.permit(:sign_in, keys: [:email, :password])
  # end

end



module Api
  module V1

    class TestController < Api::V1::BaseController
      def results
        render json: { key: 'hello' }
      end
    end

  end
end



Make a GET:

curl -X GET -H 'Content-Type: application/json' "http://legion.com:3000/api/v1/test/results?access-token=ycSNp4_TPkRdL7kmOdcb6g&uid=test@test.com&client=vu7jvVwGyqWfI65nEQ06fA"

- To use custom session controller (token)

#routes.rb
mount_devise_token_auth_for 'User', at: 'auth', controllers: {
  sessions: 'api/v1/sessions'
}

#app/api/V1/sessions_controller.rb
module Api
    module V1
        class SessionsController < ::DeviseTokenAuth::SessionsController

            def create
            ... check original source
            end
        end
    end
end




Rails 7: Devise with HotWire
============================

# https://gorails.com/episodes/devise-hotwire-turbo

- Getting error when submitting a form:

	Error: Form responses must redirect to another location

- devise.rb:

	# at head of file
	
	class TurboFailureApp < Devise::FailureApp
	  def respond
		if request_format == :turbo_stream
		  redirect
		else
		  super
		end
	  end

	  def skip_format?
		%w(html turbo_stream */*).include? request_format.to_s
	  end
	end	

	
	# within config

	config.parent_controller = 'TurboDeviseController'

	config.warden do |manager|
	manager.failure_app = TurboFailureApp
	#   manager.intercept_401 = false
	#   manager.default_strategies(scope: :user).unshift :some_external_strategy
	end

	config.navigational_formats = ['*/*', :html, :turbo_stream]

controllers/turbo_devise_controller:

	class TurboDeviseController < ApplicationController
	  class Responder < ActionController::Responder
		def to_turbo_stream
		  controller.render(options.merge(formats: :html))
		rescue ActionView::MissingTemplate => error
		  if get?
			raise error
		  elsif has_errors? && default_action
			render rendering_options.merge(formats: :html, status: :unprocessable_entity)
		  else
			redirect_to navigation_location
		  end
		end
	  end

	  self.responder = Responder
	  respond_to :html, :turbo_stream
	end

- When you login again, the cable will be disconnected .. (a case in StimilusReflux)


javascript/controllers/index.js

	import StimulusReflex from "stimulus_reflex"; // <-- add this
	import { application } from "./application"
	import { cable } from "@hotwired/turbo-rails"; // <-- add this
	import controller from '../controllers/application_controller'

	// import { eagerLoadControllersFrom } from "@hotwired/stimulus-loading";
	// eagerLoadControllersFrom("controllers", application);

	(async() => {
		const consumer = await cable.getConsumer();
		StimulusReflex.initialize(application, { controller, debug: true });
		application.consumer = consumer
		window.consumer = consumer
	})();


javascript/controllers/application_controller.js	<-- ganarated by stimilux refllux

	export default class extends Controller {
	  connect () {
		if (!window.consumer.connection.isOpen()) {
		  window.consumer.connection.open();
		}
		StimulusReflex.register(this)
	  }
	.............
	




















With DoorKeeper
===============
# https://github.com/doorkeeper-gem/doorkeeper


CORS & JWT
===========
- https://nandhae.medium.com/2019-how-i-set-up-authentication-with-jwt-in-just-a-few-lines-of-code-with-rails-5-api-devise-9db7d3cee2c0
- https://github.com/waiting-for-dev/devise-jwt
- https://betterprogramming.pub/build-a-rails-api-with-jwt-61fb8a52d833

api / auth token / cors
-----------------------
https://www.codementor.io/@omedale/simple-approach-to-rails-5-api-authentication-with-json-web-token-cpqbgrdo6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! OLD !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-  gem 'bcrypt', '~> 3.1.7'
- gem 'rack-cors', :require => 'rack/cors'
- $ gem 'jwt'


API & Auth 
============================
- https://stevepolito.design/blog/build-an-api-in-rails-with-authentication/

	
	
	
	
	
	
	
	
Rails Multitenancy
===================
- https://blog.appsignal.com/2020/12/02/building-a-multi-tenant-ruby-on-rails-app-with-subdomains.html
- https://codeburst.io/ruby-on-rails-how-to-do-multitenancy-in-2020-9c6dc112448
- https://github.com/citusdata/activerecord-multi-tenant
- https://github.com/ErwinM/acts_as_tenant













Legacy !! Installation

https://github.com/mklemme/awesome-devise
------------------------------------------------------------------------------------------
Rails 3-6: Add the following to your Gemfile

gem "devise"
gem "hpricot"
gem "ruby_parser"

Install devise in your project

$ rails generate devise:install

Generate devise for your model

$ rails generate devise MODEL
$ rake db:migrate

(Optional) Generate devise views

$ rails generate devise:views

Helpers:
---------

user_signed_in?
current_user
user_session
destroy_user_session_path (Logout)
new_user_session_path (Login)
edit_user_registration_path (Edit registration)
new_user_registration_path (Register new user)

Controller stuff

before_filter :authenticate_user!

Model
Model options

class User < ActiveRecord::Base
  devise :database_authenticatable,
    :registerable,
    :confirmable,
    :recoverable,
    :rememberable,
    :trackable,
    :validatable
end

Migration helpers

create_table :users do |t|
  t.database_authenticatable
  t.confirmable
  t.recoverable
  t.rememberable
  t.trackable
  t.timestamps
end

Routing
Authenticated and unauthenticated routes

unauthenticated do
   root :to => 'home#index'
end

authenticated do
  root :to => 'dashboard#index'
end

As

as :user do
  get 'sign_in', :to => 'devise/sessions#new'
end

Devise_for magic

devise_for :users

    # Session routes for Authenticatable (default)
         new_user_session GET  /users/sign_in                    {:controller=>"devise/sessions", :action=>"new"}
             user_session POST /users/sign_in                    {:controller=>"devise/sessions", :action=>"create"}
     destroy_user_session GET  /users/sign_out                   {:controller=>"devise/sessions", :action=>"destroy"}
   
    # Password routes for Recoverable, if User model has :recoverable configured
        new_user_password GET  /users/password/new(.:format)     {:controller=>"devise/passwords", :action=>"new"}
       edit_user_password GET  /users/password/edit(.:format)    {:controller=>"devise/passwords", :action=>"edit"}
            user_password PUT  /users/password(.:format)         {:controller=>"devise/passwords", :action=>"update"}
                          POST /users/password(.:format)         {:controller=>"devise/passwords", :action=>"create"}
   
    # Confirmation routes for Confirmable, if User model has :confirmable configured
    new_user_confirmation GET  /users/confirmation/new(.:format) {:controller=>"devise/confirmations", :action=>"new"}
        user_confirmation GET  /users/confirmation(.:format)     {:controller=>"devise/confirmations", :action=>"show"}
                          POST /users/confirmation(.:format)     {:controller=>"devise/confirmations", :action=>"create"}

Customizing devise_for

devise_for :users,
  :path => "usuarios",
  :path_names => {
    :sign_in => 'login',
    :sign_out => 'logout',
    :password => 'secret',
    :confirmation => 'verification',
    :unlock => 'unblock',
    :registration => 'register',
    :sign_up => 'cmon_let_me_in' }

Test helpers

include Devise::TestHelpers
https://github.com/plataformatec/devise/blob/1094ba65aac1d37713f2cba71f9edad76b5ca274/lib/devise/test_helpers.rb

sign_in @user
sign_out @user
	
