Elixir
------------------------------------------------------------------------------------------
https://devhints.io/elixir


> elixir
> elixirc

> iex #interactive

> "hello" <> " world"
hello world

> 40 + 3
43

> IO.puts "Hello world from Elixir"
Hello world from Elixir
:ok

test.exs:
IO.puts "Hello world from Elixir"

> elixir test.exs
Hello world from Elixir


iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple

> div(10, 2) -> 5
> div 10, 2 -> 5
> rem 10, 3 -> 1

iex> 0b1010
10

iex> round(3.58)
4
iex> trunc(3.58)
3

test.exs:
add = fn a, b -> a + b end
a = 4.5
IO.puts "a = #{a}"
IO.puts "add(3,4) = #{add.(3,4)}"

iex> byte_size("hellö")
6
iex> String.length("hellö")
5
iex> String.upcase("hellö")
"HELLÖ"

> File.read("data.txt")

--

iex> 1 = x
1
iex> 2 = x
** (MatchError) no match of right hand side value: 1

Primitives
------------
nil				Nil/null
true / false	Boolean
?a				Integer (ASCII)
23				Integer
3.14			Float
'hello'			Charlist
<<2, 3>>		Binary
"hello"			Binary string
:hello			Atom
[a, b]			List
{a, b}			Tuple
%{a: "hello"}	Map
%MyStruct{a: "hello"}	Struct
fn -> ... end	Function


types
-----
is_atom/1
is_bitstring/1
is_boolean/1
is_function/1
is_function/2
is_integer/1
is_float/1
is_binary/1
is_list/1
is_map/1
is_tuple/1
is_nil/1
is_number/1
is_pid/1
is_port/1
is_reference/1

Operators
---------
left != right   # equal
left !== right  # match
left ++ right   # concat lists
left <> right   # concat string/binary
left =~ right   # regexp

Control Flow
-------------
if false do
  "This will never be seen"
else
  "This will"
end

-

case {1, 2, 3} do
  {4, 5, 6} ->
    "This clause won't match"
  {1, x, 3} ->
    "This will match and bind x to 2"
  _ ->
   "This will match any value"
end

- 

cond do
  1 + 1 == 3 ->
    "I will never be seen"
  2 * 5 == 12 ->
    "Me neither"
  true ->
    "But I will (this is essentially an else)"
end

-

try do
  throw(:hello)
catch
  message -> "Got #{message}."
after
  IO.puts("I'm the after clause.")
end



Modules
-------------------------------------------------------------------------
require Redux   # compiles a module
import Redux    # compiles, and you can use without the `Redux.` prefix

use Redux       # compiles, and runs Redux.__using__/1
use Redux, async: true

import Redux, only: [duplicate: 2]
import Redux, only: :functions
import Redux, only: :macros

import Foo.{Bar, Baz}

alias Foo.Bar, as: Bar
alias Foo.Bar   # same as above

alias Foo.{Bar, Baz}

--

defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do	<-- private
    a + b
  end
end


Ext (ex, exs)
-------------
.ex	-->	modules name / library
-------------------------------
defmodule Math do
  def sum(a, b) do
    a + b
  end
end

$ elixirc math.ex	--> Elixir.Math.beam
$ iex

Greeter2.greet("dfdf")


.exs	--> Scripted mode
-------------------------
defmodule Math do
  def sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)

$ elixir math.exs <----- no compilation


In addition to the Elixir file extension .ex, 
Elixir also supports .exs files for scripting. 
Elixir treats both files exactly the same way, the only difference is in intention. 
.ex files are meant to be compiled while .exs files are used for scripting. 
This convention is followed by projects like mix.


defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do	<------
    false
  end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)

==

defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end


Function capturing
------------------
>iex math.exs	<---------------- pass the script to (or compile it first)


iex> Math.zero?(0)
true
iex> fun = &Math.zero?/1	<----------------------
&Math.zero?/1
iex> is_function(fun)
true
iex> fun.(0)
true


Aliasing
--------
alias Math.List
alias Math.List, as: List


some.ex:
defmodule Some do
  def sum(a, b) do
    a + b
  end
end

> elixirc some.ex --> Elixir.Some.beam

in your code (.exs)
alias Some, as: S

S.sum(1,2)

--

iex> is_atom(String)
true
iex> to_string(String)
"Elixir.String"
iex> :"Elixir.String" == String
true



iex> List.flatten([1, [2], 3])
[1, 2, 3]
iex> :"Elixir.List".flatten([1, [2], 3])
[1, 2, 3]







require
-------
Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.

iex> Integer.is_odd(3)	<--- macro
** (CompileError) iex:1: you must require Integer before invoking the macro Integer.is_odd/1
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6
iex> require Integer
Integer
iex> Integer.is_odd(3)
true

import
-------
iex> import List, only: [duplicate: 2]
List
iex> duplicate(:ok, 3)
[:ok, :ok, :ok]


defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]	<---------
    duplicate(:ok, 10)
  end
end

use
---
The use macro is frequently used as an extension point. This means that, when you use a module FooBar, you allow that module to inject any code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.

defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end

















Functions
---------
Lambdas:
square = fn n -> n*n end
square.(20)


& syntax:
square = &(&1 * &1)
square.(20)

square = &Math.square/1

* Running:
fun.(args)
apply(fun, args)
apply(module, fun, args)

Function heads:
def join(a, b \\ nil)
def join(a, b) when is_nil(b) do: a
def join(a, b) do: a <> b


numbers
--------
abs(n)
round(n)
rem(a, b)   # remainder (modulo)
div(a, b)   # integer division

import Float
n = 10.3
n |> ceil()            # → 11.0
n |> ceil(2)           # → 11.30
n |> to_string()       # → "1.030000+e01"
n |> to_string([decimals: 2, compact: true])
Float.parse("34")  # → { 34.0, "" }

Float.parse("34.1")    # → {34.1, ""}
Integer.parse("34")    # → {34, ""}
Float.to_string(34.1)  # → "3.4100e+01"
Float.to_string(34.1, [decimals: 2, compact: true])  # → "34.1"

import Integer
n = 12
n |> digits()         # → [1, 2]
n |> to_charlist()    # → '12'
n |> to_string()      # → "12"
n |> is_even()
n |> is_odd()
# Different base:
n |> digits(2)        # → [1, 1, 0, 0]
n |> to_charlist(2)   # → '1100'
n |> to_string(2)     # → "1100"
parse("12")           # → {12, ""}
undigits([1, 2])      # → 12


String
------
str = "hello"
str |> length()        # → 5
str |> codepoints()    # → ["h", "e", "l", "l", "o"]
str |> slice(2..-1)    # → "llo"
str |> split(" ")      # → ["hello"]
str |> capitalize()    # → "Hello"
str |> match(regex)


Enums
-----
import Enum
list = [:a, :b, :c]
list |> at(0)         # → :a
list |> count()       # → 3
list |> empty?()      # → false
list |> any?()        # → true
list |> concat([:d])  # → [:a, :b, :c, :d]
Also, consider streams instead.



Maps
----
user = %{
  name: "John",
  city: "Melbourne"
}
IO.puts "Hello, " <> user.name

Map.new([{:b, 1}, {:a, 2}])
Map.new([a: 1, b: 2])
Map.new([:a, :b], fn x -> {x, x} end)  # → %{a: :a, b: :b}

m = %{name: "hi"}       # atom keys (:name)
m = %{"name" => "hi"}   # string keys ("name")

m |> delete(:name)  # → %{}
m |> pop(:name)     # → {"John", %{}}

m |> get(:id)       # → 1
m |> keys()         # → [:id, :name]
m |> values()       # → [1, "hi"]
m |> to_list()      # → [id: 1, name: "hi"]
                    # → [{:id, 1}, {:name, "hi"}]
import Map
m = %{m | name: "yo"}  # key must exist
m |> put(:id, 2)      # → %{id: 2, name: "hi"}
m |> put_new(:id, 2)  # only if `id` doesn't exist (`||=`)
m |> put(:b, "Banana")
m |> merge(%{b: "Banana"})
m |> update(:a, &(&1 + 1))
m |> update(:a, fun a -> a + 1 end)
m |> get_and_update(:a, &(&1 || "default"))
# → {old, new}


Map/reduce
----------
list |> reduce(fn)
list |> reduce(acc, fn)
list |> map(fn)
list |> reject(fn)
list |> any?(fn)
list |> empty?(fn)
[1, 2, 3, 4]
|> Enum.reduce(0, fn(x, acc) -> x + acc end)


Pattern matching
-----------------
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}
iex> a
:hello
iex> b
"world"

--> ** (MatchError) no match of right hand side value: {:hello, "world"}


Pattern matching in functions
------------------------------
def greet(%{name: username}) do
  IO.puts "Hello, " <> username
end

user = %{name: "Tom", age: 23}


Lists
-----
users = [ "Tom", "Dick", "Harry" ]
 
Enum.map(users, fn user ->
  IO.puts "Hello " <> user
end)


import List
l = [ 1, 2, 3, 4 ]
l = l ++ [5]         # push (append)
l = [ 0 | list ]     # unshift (prepend)
l |> first()
l |> last()
l |> flatten()
l |> flatten(tail)


Tuples
--------
import Tuple
t = { :a, :b }
t |> elem(1)    # like tuple[1]
t |> put_elem(index, value)
t |> tuple_size()

list = [{ :name, "John" }, { :age, 15 }]
list[:name]
# For string-keyed keyword lists
list = [{"size", 2}, {"type", "shoe"}]
List.keyfind(list, "size", 0)  # → {"size", 2}


Structs
-------
Structs
defmodule User do
  defstruct name: "", age: nil
end

%User{name: "John", age: 20}

%User{}.struct  # → User
See: Structs


Loops
-----
for n <- [1, 2, 3, 4], do: n * n
for n <- 1..4, do: n * n
for {key, val} <- %{a: 10, b: 20}, do: val
# → [10, 20]
for {key, val} <- %{a: 10, b: 20}, into: %{}, do: {key, val*val}

for n <- 1..10, rem(n, 2) == 0, do: n
# → [2, 4, 6, 8, 10]

for dir <- dirs,
    file <- File.ls!(dir),          # nested comprehension
    path = Path.join(dir, file),    # invoked
    File.regular?(path) do          # condition
	IO.puts(file)
end



Piping
------
source
|> transform(:hello)
|> print()
 
 
# Same as:
print(transform(source, :hello))
These two are equivalent.


Metaprogramming
----------------

__MODULE__
__MODULE__.__info__

@after_compile __MODULE__
def __before_compile__(env)
def __after_compile__(env, _bytecode)
def __using__(opts)    # invoked on `use`

@on_definition {__MODULE__, :on_def}
def on_def(_env, kind, name, args, guards, body)

@on_load :load_check
def load_check




https://learnxinyminutes.com/docs/elixir/
---------------------------------------------------------------------------------

Hello World
-----------

# hello.exs
defmodule Greeter do
  def greet(name) do
    message = "Hello, " <> name <> "!"
    IO.puts message
  end
end

Greeter.greet("world")
elixir hello.exs
# Hello, world!















